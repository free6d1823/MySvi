/** @file ddr_target_lib.c

  Functions for DDRTargetLib

  Copyright (c) 2017-2018 Qualcomm Datacenter Technologies, Inc.
  All Rights Reserved.
  Confidential and Proprietary - Qualcomm Datacenter Technologies, Inc.

  Copyright (c) 2014-2016 Qualcomm Technologies, Inc.
  All Rights Reserved.
  Confidential and Proprietary - Qualcomm Technologies, Inc.

**/



/*==========================================================================
                               INCLUDE FILES
===========================================================================*/
#include <string.h>
#include <stdarg.h>
#include <stdio.h>
#include <target/ddr.h>
#include <target/smbus.h>
#include <target/delay.h>
#include <asm/mach/chipinfo.h>
#include <errno.h>
/*==========================================================================
                             DEFINED CONSTANTS
===========================================================================*/
// SPD read mask definition
#define SPD_BYTES_TOTAL___M                 0x00000007
#define SPD_BYTES_TOTAL___S                 0x4
#define SPD_BYTES_TOTAL_UNDEFINED           0x00
#define SPD_BYTES_TOTAL_256                 0x01
#define SPD_BYTES_TOTAL_512                 0x02

#define max(a,b) (((a) > (b)) ? (a) : (b))

/*===========================================================================
                                 DATA
===========================================================================*/
extern ddr_func_tbl ddr_function_table;

// Globals - can we refactor these away?
static char printf_buffer[256] = {0};

// I2C Hob Data pointer
static I2cDefaultHobData *hobData;
static I2cDefaultHobData defaultI2cHobData;
// SPD table offset array
static uint16_t spd_offset[DDR_MAX_NUM_CHANS][DDR_MAX_NUM_SLOTS_PER_CHAN];
static void *spd_cached_base = NULL;
// DDR SI Base Address
extern unsigned long ddrsi_base;
// DDR Margining Result Base Address
extern unsigned long ddr_margining_result;

typedef struct
{
    uint16_t readVer[2];
    uint16_t mapVer[2];
}SoCCompatible_t;

/**
  Target type of the device on which the platform is running.
 */
typedef enum
{
  DALPLATFORMINFO_TYPE_UNKNOWN      = 0x00,  /**< Unknown target device. */
  DALPLATFORMINFO_TYPE_RUMI         = 0x0F,  /**< Target is on RUMI. */
  DALPLATFORMINFO_TYPE_VIRTIO       = 0x10,  /**< Target is on VIRTIO. */
  DALPLATFORMINFO_TYPE_CRB          = 0x1A,  /**< Target is a CRB device. */
  DALPLATFORMINFO_TYPE_SDP          = 0x1B,  /**< Target is a SDP device. */

  DALPLATFORMINFO_NUM_TYPES, /**< Number of known targets (including unknown). */
  /** @cond */
  DALPLATFORMINFO_TYPE_8BITS        = 0x7F
  /** @endcond */
} DalPlatformInfoPlatformType;

static SoCCompatible_t ddrsi_compatible_table[]=
{
    // read version, mapped version
    {{1,0},{1,0}},
    {{1,1},{1,0}},
    {{2,0},{1,0}},
};

#ifdef CONFIG_PRE_HAPS
//#define outp32 write32
//#define inp32 read32
#define BASE_DDR_REG_0 0xff1c000000 //ddr0
#define BASE_DDR_REG_1 0xff1a000000 //ddr1
#define BASE_DDR_REG_2 0xff04000000 //ddr2
#define BASE_DDR_REG_3 0xff06000000 //ddr3
#define BASE_DDR_REG_4 0xff0a000000 //ddr4
#define BASE_DDR_REG_5 0xff20000000 //ddr5

#define FPGA_HAPS_PHY_GENERAL_SETUP                         (0x01000000 + 0x00*4)
#define FPGA_HAPS_PHY_PLAYBACK_ENABLE                       (0x01000000 + 0x04*4)
#define FPGA_HAPS_PHY_PLAYBACK_STATUS                       (0x01000000 + 0x08*4)
#define FPGA_HAPS_PHY_WRITE_PIPE_DELAY                      (0x01000000 + 0x0C*4)
#define FPGA_HAPS_PHY_CA_PIPE_DELAY                         (0x01000000 + 0x10*4)
#define FPGA_HAPS_PHY_DATA_BYTE_SEL                         (0x01000000 + 0x14*4)
#define FPGA_HAPS_PHY_CTRLUPD_CONFIG                        (0x01000000 + 0x18*4)
#define FPGA_HAPS_PHY_DEBUG                                 (0x01000000 + 0x1C*4)
#define FPGA_HAPS_PHY_INTERRUPT_MASK                        (0x01000000 + 0x20*4)
#define FPGA_HAPS_PHY_INTERRUPT_ENABLE                      (0x01000000 + 0x24*4)
#define FPGA_HAPS_PHY_INTERRUPT_STATUS                      (0x01000000 + 0x28*4)
#define FPGA_HAPS_PHY_INTERRUPT_CLEAR                       (0x01000000 + 0x2C*4)
#define FPGA_HAPS_PHY_DFICLK_READ_DELAY_RANK_0              (0x01000000 + 0x30*4)
#define FPGA_HAPS_PHY_FCLK_READ_DELAY_RANK_0_BYTES_7_0      (0x01000000 + 0x34*4)
#define FPGA_HAPS_PHY_FCLK_READ_DELAY_RANK_0_BYTE_8         (0x01000000 + 0x38*4)
#define FPGA_HAPS_PHY_DFICLK_READ_DELAY_RANK_1              (0x01000000 + 0x40*4)
#define FPGA_HAPS_PHY_FCLK_READ_DELAY_RANK_1_BYTES_7_0      (0x01000000 + 0x44*4)
#define FPGA_HAPS_PHY_FCLK_READ_DELAY_RANK_1_BYTE_8         (0x01000000 + 0x48*4)
#define FPGA_HAPS_PHY_FCLK_READ_OFFSET_RANK_0_BYTES_7_0     (0x01000000 + 0x50*4)
#define FPGA_HAPS_PHY_FCLK_READ_OFFSET_RANK_0_BYTE_8        (0x01000000 + 0x54*4)
#define FPGA_HAPS_PHY_FCLK_READ_OFFSET_RANK_1_BYTES_7_0     (0x01000000 + 0x58*4)
#define FPGA_HAPS_PHY_FCLK_READ_OFFSET_RANK_1_BYTE_8        (0x01000000 + 0x5C*4)
#define FPGA_HAPS_PHY_AUTOTRAIN_LOOP_ADDR                   (0x01000000 + 0x60*4)
#define FPGA_HAPS_PHY_TRAIN_STATUS                          (0x01000000 + 0x64*4)
#define FPGA_HAPS_PHY_READ_TRAINING_CAPTURE_0               (0x01000000 + 0x68*4)
#define FPGA_HAPS_PHY_READ_TRAINING_CAPTURE_1               (0x01000000 + 0x6C*4)
#define FPGA_HAPS_PHY_REVISION_REGISTER                     (0x01000000 + 0x70*4)
#define FPGA_HAPS_PHY_READ_PHASE_DELAY_RANK_0               (0x01000000 + 0x74*4)
#define FPGA_HAPS_PHY_READ_PHASE_DELAY_RANK_1               (0x01000000 + 0x78*4)
#define FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE(x)               (0x01000000 + 0x800*4 +0x10*(x))

void mddr_drv_cfg(int inst){
    long int BASE_DDR_REG;
    int val;

    if(inst==0)      BASE_DDR_REG = BASE_DDR_REG_0;
    else if(inst==1) BASE_DDR_REG = BASE_DDR_REG_1;
    else if(inst==2) BASE_DDR_REG = BASE_DDR_REG_2;
    else if(inst==3) BASE_DDR_REG = BASE_DDR_REG_3;
    else if(inst==4) BASE_DDR_REG = BASE_DDR_REG_4;
    else             BASE_DDR_REG = BASE_DDR_REG_5;

    //monaco_log(CRITICAL, "Begin to init DDR for HAPS\n");
    //monaco_log(CRITICAL, "Begin to switch CLK to branch C\n");
    val = outp32(0xff082a0018,0x2);

    //monaco_log(CRITICAL, "Begin to reset DDR PHY\n");
    val =inp32(0xff082a0014);
    //monaco_log(CRITICAL, "DDR PHY reg read value is %x\n",val);
    val = outp32(0xff082a0014,0x3);
    monaco_log(CRITICAL, "Delay for wait 0xff082a0014,0x3\n");
    monaco_log(CRITICAL, "Delay for wait 0xff082a0014,0x3\n");
    monaco_log(CRITICAL, "Delay for wait 0xff082a0014,0x3\n");
    monaco_log(CRITICAL, "Delay for wait 0xff082a0014,0x3\n");
    monaco_log(CRITICAL, "Delay for wait 0xff082a0014,0x3\n");
    monaco_log(CRITICAL, "Delay for wait 0xff082a0014,0x3\n");
    val = outp32(0xff082a0014,0x0);

    val = outp32(BASE_DDR_REG+0x020204,0x0F000400); //DDR_MANUAL_CKE
    val = outp32(BASE_DDR_REG+0x020204,0x0F000000); //DDR_MANUAL_CKE
    val = inp32(BASE_DDR_REG+0x0701DC); //SW_RESET until get 0x00000000
    val = outp32(BASE_DDR_REG+0x0701DC,0x00000001); //SW_RESET
    val = outp32(BASE_DDR_REG+0x0700DC,0x00000004); //RESETSM_CNTRL
    val = outp32(BASE_DDR_REG+0x0701E8,0x00000002); //CMN_CONFIG
    val = outp32(BASE_DDR_REG+0x0701C4,0x00000026); //CLK_SELECT
    val = outp32(BASE_DDR_REG+0x0700D4,0x0000000A); //SYSCLK_EN_SEL
    val = outp32(BASE_DDR_REG+0x070058,0x0000000E); //CLK_ENABLE1
    val = outp32(BASE_DDR_REG+0x070098,0x00000020); //BGV_TRIM
    val = outp32(BASE_DDR_REG+0x07009C,0x0000000F); //BGT_TRIM
    val = outp32(BASE_DDR_REG+0x0700A4,0x00000020); //CLK_IPTRIM
    val = outp32(BASE_DDR_REG+0x0700A0,0x00000020); //CLK_IETRIM
    val = outp32(BASE_DDR_REG+0x070068,0x0000000F); //PLL_IVCO
    val = outp32(BASE_DDR_REG+0x07021C,0x00000005); //CMN_MODE
    val = outp32(BASE_DDR_REG+0x070060,0x00000006); //SYSCLK_BUF_ENABLE
    val = outp32(BASE_DDR_REG+0x0700E4,0x000000B5); //RESTRIM_CTRL
    val = outp32(BASE_DDR_REG+0x0701F0,0x00000004); //CMN_RATE_OVERRIDE
    val = outp32(BASE_DDR_REG+0x0701F4,0x00000015); //SVS_MODE_CLK_SEL
    val = outp32(BASE_DDR_REG+0x070170,0x00000000); //VCO_TUNE_MAP
    val = outp32(BASE_DDR_REG+0x0701EC,0x00000000); //CMN_CONFIG_2
    val = outp32(BASE_DDR_REG+0x0701E0,0x00000002); //CORE_CLK_EN
    val = outp32(BASE_DDR_REG+0x07016C,0x0000001C); //VCO_TUNE_CTRL
    val = outp32(BASE_DDR_REG+0x0700C4,0x00000034); //PLL_CCTRL_MODE0
    val = outp32(BASE_DDR_REG+0x0700B8,0x00000016); //PLL_RCTRL_MODE0
    val = outp32(BASE_DDR_REG+0x0700AC,0x00000008); //CP_CTRL_MODE0
    val = outp32(BASE_DDR_REG+0x0700F8,0x0000002C); //DEC_START_MODE0
    val = outp32(BASE_DDR_REG+0x0700FC,0x00000001); //DEC_START_MSB_MODE0
    val = outp32(BASE_DDR_REG+0x070114,0x00000000); //DIV_FRAC_START1_MODE0
    val = outp32(BASE_DDR_REG+0x070118,0x00000000); //DIV_FRAC_START2_MODE0
    val = outp32(BASE_DDR_REG+0x07011C,0x00000000); //DIV_FRAC_START3_MODE0
    val = outp32(BASE_DDR_REG+0x070148,0x0000003F); //INTEGLOOP_GAIN0_MODE0
    val = outp32(BASE_DDR_REG+0x07014C,0x00000000); //INTEGLOOP_GAIN1_MODE0
    val = outp32(BASE_DDR_REG+0x0701D8,0x00000005); //CORECLK_DIV
    val = outp32(BASE_DDR_REG+0x0701C8,0x00000022); //HSCLK_SEL1
    val = outp32(BASE_DDR_REG+0x070174,0x0000007C); //VCO_TUNE1_MODE0
    val = outp32(BASE_DDR_REG+0x070178,0x00000000); //VCO_TUNE2_MODE0
    val = outp32(BASE_DDR_REG+0x07006C,0x00000000); //LOCK_CMP1_MODE0
    val = outp32(BASE_DDR_REG+0x070070,0x00000018); //LOCK_CMP2_MODE0
    val = outp32(BASE_DDR_REG+0x070074,0x00000000); //LOCK_CMP3_MODE0
    val = outp32(BASE_DDR_REG+0x0700E0,0x00000028); //RESETSM_CNTRL2
    val = inp32(BASE_DDR_REG+0x0701DC); //SW_RESET until get 0x00000001
    val = outp32(BASE_DDR_REG+0x0701DC,0x00000000); //SW_RESET
    val = outp32(BASE_DDR_REG+0x0700DC,0x00000006); //RESETSM_CNTRL

    val = inp32(BASE_DDR_REG+0x0701E4);
    //monaco_log(CRITICAL, "Begin to polling 0x0701E4\n");
    while (val!=1){
        val = inp32(BASE_DDR_REG+0x0701E4);
    }
    //monaco_log(CRITICAL, "Begin to polling 0x0701E4 done\n");

    val = outp32(BASE_DDR_REG+0x020204,0x0F000400); //DDR_MANUAL_CKE
    val = outp32(BASE_DDR_REG+0x020204,0x0F000100); //DDR_MANUAL_CKE
    val = outp32(BASE_DDR_REG+0x020204,0x0F000020); //DDR_MANUAL_CKE
    val = outp32(BASE_DDR_REG+0x020204,0x0F000000); //DDR_MANUAL_CKE
    val = outp32(BASE_DDR_REG+0x020200,0x00000010); //DDR_MANUAL
    val = inp32(BASE_DDR_REG+0x020234); //CSR_CNTL until get 0x00000000
    val = outp32(BASE_DDR_REG+0x020234,0x00000000); //CSR_CNTL
    val = outp32(BASE_DDR_REG+0x000104,0x00000121); //DIMM_TECH
    val = outp32(BASE_DDR_REG+0x00010c,0x00000001); //Rank enable
    //val = outp32(BASE_DDR_REG+0x00010c,0x00000003); //Rand enable

    val = outp32(BASE_DDR_REG+0x000120,0x08000301); //DIMM_SLOT0_CONFIG
    //val = outp32(BASE_DDR_REG+0x000120,0x08010301); //DIMM_SLOT0_CONFIG
    val = outp32(BASE_DDR_REG+0x000108,0x00000001); //ADDR_DECODE_CNTL
    val = outp32(BASE_DDR_REG+0x000124,0x00030000); //DIMM_SLOT0_ADDR
    val = outp32(BASE_DDR_REG+0x000418,0x00000090); //DATAFLOW_CNTL
    val = outp32(BASE_DDR_REG+0x000110,0x00000606); //TN_TOKEN_CNT
    val = outp32(BASE_DDR_REG+0x000438,0x00020100); //DDR_CA_BUS_CNTL
    val = outp32(BASE_DDR_REG+0x00043C,0x00000001); //DDR_DQ_BUS_CNTL
    val = outp32(BASE_DDR_REG+0x000448,0x00002E90); //DDR_PWR_DOWN_CNTL
    val = outp32(BASE_DDR_REG+0x00044C,0x002CEE20); //DDR_SELF_REF_CNTL
    val = outp32(BASE_DDR_REG+0x020238,0x00000030); //DDR_AUTO_REF_CNTL
    val = outp32(BASE_DDR_REG+0x000454,0x00000000); //DDR_ZQCAL_CNTL
    val = outp32(BASE_DDR_REG+0x000458,0xA2071D33); //DDR_ODT_WR_CNTL
    val = outp32(BASE_DDR_REG+0x00045C,0x1242747E); //DDR_ODT_RD_CNTL
    val = outp32(BASE_DDR_REG+0x000480,0x054AEC50); //DDR_DFI_CNTL
    val = outp32(BASE_DDR_REG+0x000484,0x00000000); //DDR_PHY_CNTL
    val = outp32(BASE_DDR_REG+0x020234,0x00000000); //CSR_CNTL
    val = outp32(BASE_DDR_REG+0x000504,0x05441400); //TIMING_DRAM_RDWR_1
    val = inp32(BASE_DDR_REG+0x000418); //DATAFLOW_CNTL until get 0x00000090
    val = inp32(BASE_DDR_REG+0x000504); //TIMING_DRAM_RDWR_1 until get 0x05441400
    val = inp32(BASE_DDR_REG+0x000438); //DDR_CA_BUS_CNTL until get 0x00020100
    val = outp32(BASE_DDR_REG+0x000500,0x09090000); //TIMING_DRAM_RDWR_0
    val = outp32(BASE_DDR_REG+0x000508,0x00010202); //TIMING_DRAM_RDWR_2
    val = outp32(BASE_DDR_REG+0x00050C,0x00404004); //TIMING_DRAM_RDWR_3
    val = outp32(BASE_DDR_REG+0x000510,0x00010205); //TIMING_DRAM_RDWR_4
    val = outp32(BASE_DDR_REG+0x000514,0x0004E007); //TIMING_DRAM_AUTO_REF_0
    val = outp32(BASE_DDR_REG+0x000518,0x00004000); //TIMING_DRAM_AUTO_REF_1
    val = outp32(BASE_DDR_REG+0x00051C,0x00000003); //TIMING_DRAM_AUTO_REF_2
    val = outp32(BASE_DDR_REG+0x000520,0x00000404); //TIMING_DRAM_PWR_DOWN_0
    val = inp32(BASE_DDR_REG+0x000500); //TIMING_DRAM_RDWR_0 until get 0x09090000
    val = outp32(BASE_DDR_REG+0x000524,0x22000E0E); //TIMING_DRAM_PWR_DOWN_1
    val = outp32(BASE_DDR_REG+0x000528,0x03040505); //TIMING_DRAM_SELF_REF_0
    val = outp32(BASE_DDR_REG+0x00052C,0x00006300); //TIMING_DRAM_SELF_REF_1
    val = outp32(BASE_DDR_REG+0x000530,0x00003003); //TIMING_DRAM_SELF_REF_2
    val = outp32(BASE_DDR_REG+0x000534,0x00000080); //TIMING_DRAM_ZQ_0
    val = outp32(BASE_DDR_REG+0x000538,0x00400200); //TIMING_DRAM_ZQ_1
    val = outp32(BASE_DDR_REG+0x00053C,0x18081801); //TIMING_DRAM_MR_0
    val = outp32(BASE_DDR_REG+0x000540,0x00000118); //TIMING_DRAM_MR_1
    val = outp32(BASE_DDR_REG+0x000544,0x0000306C); //TIMING_DRAM_MPSM
    val = outp32(BASE_DDR_REG+0x000548,0x00046046); //TIMING_ODT
    val = outp32(BASE_DDR_REG+0x000550,0x23133313); //TIMING_ADJ_RDWR_0
    val = outp32(BASE_DDR_REG+0x000554,0x00000000); //TIMING_ADJ_RDWR_1
    val = outp32(BASE_DDR_REG+0x000558,0x00000007); //TIMING_ADJ_AUTO_REF
    val = outp32(BASE_DDR_REG+0x00055C,0x0000002A); //TIMING_ADJ_ZQ
    val = outp32(BASE_DDR_REG+0x000568,0x00000000); //TIMING_RCD
    val = inp32(BASE_DDR_REG+0x000500); //TIMING_DRAM_RDWR_0 until get 0x09090000
    val = outp32(BASE_DDR_REG+0x000560,0x00001008); //TIMING_DFI_0
    val = outp32(BASE_DDR_REG+0x000564,0x007110CC); //TIMING_DFI_1
    val = outp32(BASE_DDR_REG+0x00056C,0x00000010); //TIMING_DQ_BUS
    val = inp32(BASE_DDR_REG+0x020234); //CSR_CNTL until get 0x00000000
    val = outp32(BASE_DDR_REG+0x020234,0x00000000); //CSR_CNTL
    val = outp32(BASE_DDR_REG+0x000400,0x00001010); //CMD_EXEC_CNTL_0
    val = outp32(BASE_DDR_REG+0x000680,0x211C3632); //WDB_FLUSH_WM
    val = outp32(BASE_DDR_REG+0x000684,0x027821F4); //WDB_FLUSH_CNTL
    val = outp32(BASE_DDR_REG+0x000688,0x000009A1); //WDB_FLUSH_PH
    val = outp32(BASE_DDR_REG+0x000404,0x0A080F09); //CMD_EXEC_CNTL_1
    val = outp32(BASE_DDR_REG+0x0003F8,0xF8000618); //CMD_EXEC_CNTL_6
    val = outp32(BASE_DDR_REG+0x0003FC,0x78000208); //CMD_EXEC_CNTL_7
    val = outp32(BASE_DDR_REG+0x00040C,0x1041001E); //CMD_EXEC_CNTL_3
    val = outp32(BASE_DDR_REG+0x000410,0x00040000); //CMD_EXEC_CNTL_4
    val = outp32(BASE_DDR_REG+0x000414,0x0000033E); //CMD_EXEC_CNTL_5
    val = outp32(BASE_DDR_REG+0x000450,0x00000000); //DDR_ZQCAL_EN
    val = outp32(BASE_DDR_REG+0x020234,0x00000001); //CSR_CNTL
    val = inp32(BASE_DDR_REG+0x020200); //DDR_MANUAL until get 0x00000010
    val = outp32(BASE_DDR_REG+0x020200,0x00000000); //DDR_MANUAL
    val = inp32(BASE_DDR_REG+0x10001C0); //FPGA_HAPS_PHY_REVISION_REGISTER until get 0x00000202
    val = outp32(BASE_DDR_REG+0x1000090,0x00000001); //FPGA_HAPS_PHY_INTERRUPT_ENABLE
    val = outp32(BASE_DDR_REG+0x1000080,0x00000000); //FPGA_HAPS_PHY_INTERRUPT_MASK
    val = outp32(BASE_DDR_REG+0x1000030,0x00000005); //FPGA_HAPS_PHY_WRITE_PIPE_DELAY
    val = outp32(BASE_DDR_REG+0x1000040,0x00000001); //FPGA_HAPS_PHY_CA_PIPE_DELAY
    val = outp32(BASE_DDR_REG+0x10000C0,0x0002AAAA); //FPGA_HAPS_PHY_DFICLK_READ_DELAY_RANK_0
    val = outp32(BASE_DDR_REG+0x10000D0,0x88888888); //FPGA_HAPS_PHY_FCLK_READ_DELAY_RANK_0_BYTES_7_0
    val = outp32(BASE_DDR_REG+0x10000E0,0x00000008); //FPGA_HAPS_PHY_FCLK_READ_DELAY_RANK_0_BYTE_8
    val = outp32(BASE_DDR_REG+0x1000100,0x0002AAAA); //FPGA_HAPS_PHY_DFICLK_READ_DELAY_RANK_1
    val = outp32(BASE_DDR_REG+0x1000110,0x88888888); //FPGA_HAPS_PHY_FCLK_READ_DELAY_RANK_1_BYTES_7_0
    val = outp32(BASE_DDR_REG+0x1000120,0x00000008); //FPGA_HAPS_PHY_FCLK_READ_DELAY_RANK_1_BYTE_8
    val = outp32(BASE_DDR_REG+0x1000000,0x00000095); //FPGA_HAPS_PHY_GENERAL_SETUP
    val = outp32(BASE_DDR_REG+0x1002000,0x288000F0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_0
    val = outp32(BASE_DDR_REG+0x1002010,0x008000F0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_1
    val = outp32(BASE_DDR_REG+0x1002020,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_2
    val = outp32(BASE_DDR_REG+0x1002030,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_3
    val = outp32(BASE_DDR_REG+0x1002040,0x00000FA0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_4
    val = outp32(BASE_DDR_REG+0x1002080,0x808000F0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_8
    val = outp32(BASE_DDR_REG+0x1002090,0x808000F0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_9
    val = outp32(BASE_DDR_REG+0x10020A0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_10
    val = outp32(BASE_DDR_REG+0x10020B0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_11
    val = outp32(BASE_DDR_REG+0x10020C0,0x00002710); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_12
    val = outp32(BASE_DDR_REG+0x1002100,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_16
    val = outp32(BASE_DDR_REG+0x1002110,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_17
    val = outp32(BASE_DDR_REG+0x1002120,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_18
    val = outp32(BASE_DDR_REG+0x1002130,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_19
    val = outp32(BASE_DDR_REG+0x1002140,0x0000000E); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_20
    val = outp32(BASE_DDR_REG+0x1002180,0xB88000E3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_24
    val = outp32(BASE_DDR_REG+0x1002190,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_25
    val = outp32(BASE_DDR_REG+0x10021A0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_26
    val = outp32(BASE_DDR_REG+0x10021B0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_27
    val = outp32(BASE_DDR_REG+0x10021C0,0x00000000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_28
    val = outp32(BASE_DDR_REG+0x1002200,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_32
    val = outp32(BASE_DDR_REG+0x1002210,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_33
    val = outp32(BASE_DDR_REG+0x1002220,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_34
    val = outp32(BASE_DDR_REG+0x1002230,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_35
    val = outp32(BASE_DDR_REG+0x1002240,0x00000004); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_36
    val = outp32(BASE_DDR_REG+0x1002280,0xB8808FE3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_40
    val = outp32(BASE_DDR_REG+0x1002290,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_41
    val = outp32(BASE_DDR_REG+0x10022A0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_42
    val = outp32(BASE_DDR_REG+0x10022B0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_43
    val = outp32(BASE_DDR_REG+0x10022C0,0x00000000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_44
    val = outp32(BASE_DDR_REG+0x1002300,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_48
    val = outp32(BASE_DDR_REG+0x1002310,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_49
    val = outp32(BASE_DDR_REG+0x1002320,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_50
    val = outp32(BASE_DDR_REG+0x1002330,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_51
    val = outp32(BASE_DDR_REG+0x1002340,0x00000004); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_52
    val = outp32(BASE_DDR_REG+0x1002380,0xB8809DE3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_56
    val = outp32(BASE_DDR_REG+0x1002390,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_57
    val = outp32(BASE_DDR_REG+0x10023A0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_58
    val = outp32(BASE_DDR_REG+0x10023B0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_59
    val = outp32(BASE_DDR_REG+0x10023C0,0x00000000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_60
    val = outp32(BASE_DDR_REG+0x1002400,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_64
    val = outp32(BASE_DDR_REG+0x1002410,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_65
    val = outp32(BASE_DDR_REG+0x1002420,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_66 
    val = outp32(BASE_DDR_REG+0x1002430,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_67
    val = outp32(BASE_DDR_REG+0x1002440,0x00000004); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_68
    val = outp32(BASE_DDR_REG+0x1002480,0xB880A7E3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_72
    val = outp32(BASE_DDR_REG+0x1002490,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_73
    val = outp32(BASE_DDR_REG+0x10024A0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_74
    val = outp32(BASE_DDR_REG+0x10024B0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_75
    val = outp32(BASE_DDR_REG+0x10024C0,0x00000000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_76
    val = outp32(BASE_DDR_REG+0x1002500,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_80
    val = outp32(BASE_DDR_REG+0x1002510,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_81
    val = outp32(BASE_DDR_REG+0x1002520,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_82
    val = outp32(BASE_DDR_REG+0x1002530,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_83
    val = outp32(BASE_DDR_REG+0x1002540,0x00000004); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_84
    val = outp32(BASE_DDR_REG+0x1002580,0xB880D4E3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_88
    val = outp32(BASE_DDR_REG+0x1002590,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_89
    val = outp32(BASE_DDR_REG+0x10025A0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_90
    val = outp32(BASE_DDR_REG+0x10025B0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_91
    val = outp32(BASE_DDR_REG+0x10025C0,0x00000000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_92
    val = outp32(BASE_DDR_REG+0x1002600,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_96
    val = outp32(BASE_DDR_REG+0x1002610,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_97
    val = outp32(BASE_DDR_REG+0x1002620,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_98
    val = outp32(BASE_DDR_REG+0x1002630,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_99
    val = outp32(BASE_DDR_REG+0x1002640,0x00000010); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_100
    val = outp32(BASE_DDR_REG+0x1002680,0xB880F4E3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_104
    val = outp32(BASE_DDR_REG+0x1002690,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_105
    val = outp32(BASE_DDR_REG+0x10026A0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_106
    val = outp32(BASE_DDR_REG+0x10026B0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_107
    val = outp32(BASE_DDR_REG+0x10026C0,0x00000000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_108
    val = outp32(BASE_DDR_REG+0x1002700,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_112
    val = outp32(BASE_DDR_REG+0x1002710,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_113
    val = outp32(BASE_DDR_REG+0x1002720,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_114
    val = outp32(BASE_DDR_REG+0x1002730,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_115
    val = outp32(BASE_DDR_REG+0x1002740,0x00000010); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_116
    val = outp32(BASE_DDR_REG+0x1002780,0x988000E3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_120
    val = outp32(BASE_DDR_REG+0x1002790,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_121
    val = outp32(BASE_DDR_REG+0x10027A0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_122
    val = outp32(BASE_DDR_REG+0x10027B0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_123
    val = outp32(BASE_DDR_REG+0x10027C0,0x00000000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_124
    val = outp32(BASE_DDR_REG+0x1002800,0x988000D3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_128
    val = outp32(BASE_DDR_REG+0x1002810,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_129
    val = outp32(BASE_DDR_REG+0x1002820,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_130
    val = outp32(BASE_DDR_REG+0x1002830,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_131
    val = outp32(BASE_DDR_REG+0x1002840,0x00000000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_132
    val = outp32(BASE_DDR_REG+0x1002880,0xE0EBF8E3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_136
    val = outp32(BASE_DDR_REG+0x1002890,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_137
    val = outp32(BASE_DDR_REG+0x10028A0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_138
    val = outp32(BASE_DDR_REG+0x10028B0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_139
    val = outp32(BASE_DDR_REG+0x10028C0,0x00000000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_140
    val = outp32(BASE_DDR_REG+0x1002900,0xE0EBF8D3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_144
    val = outp32(BASE_DDR_REG+0x1002910,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_145
    val = outp32(BASE_DDR_REG+0x1002920,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_146
    val = outp32(BASE_DDR_REG+0x1002930,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_147
    val = outp32(BASE_DDR_REG+0x1002940,0x00000000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_148
    val = outp32(BASE_DDR_REG+0x1002980,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_152
    val = outp32(BASE_DDR_REG+0x1002990,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_153
    val = outp32(BASE_DDR_REG+0x10029A0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_154
    val = outp32(BASE_DDR_REG+0x10029B0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_155
    val = outp32(BASE_DDR_REG+0x10029C0,0x00000004); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_156
    val = outp32(BASE_DDR_REG+0x1002A00,0xB08000E3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_160
    val = outp32(BASE_DDR_REG+0x1002A10,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_161
    val = outp32(BASE_DDR_REG+0x1002A20,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_162
    val = outp32(BASE_DDR_REG+0x1002A30,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_163
    val = outp32(BASE_DDR_REG+0x1002A40,0x00000000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_164
    val = outp32(BASE_DDR_REG+0x1002A80,0xB08000D3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_168
    val = outp32(BASE_DDR_REG+0x1002A90,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_169
    val = outp32(BASE_DDR_REG+0x1002AA0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_170
    val = outp32(BASE_DDR_REG+0x1002AB0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_171
    val = outp32(BASE_DDR_REG+0x1002AC0,0x00000000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_172
    val = outp32(BASE_DDR_REG+0x1002B00,0xC8EBF8E3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_176
    val = outp32(BASE_DDR_REG+0x1002B10,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_177
    val = outp32(BASE_DDR_REG+0x1002B20,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_178
    val = outp32(BASE_DDR_REG+0x1002B30,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_179
    val = outp32(BASE_DDR_REG+0x1002B40,0x00000000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_180
    val = outp32(BASE_DDR_REG+0x1002B80,0xC8EBF8D3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_184
    val = outp32(BASE_DDR_REG+0x1002B90,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_185
    val = outp32(BASE_DDR_REG+0x1002BA0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_186
    val = outp32(BASE_DDR_REG+0x1002BB0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_187
    val = outp32(BASE_DDR_REG+0x1002BC0,0x00000000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_188
    val = outp32(BASE_DDR_REG+0x1002C00,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_192
    val = outp32(BASE_DDR_REG+0x1002C10,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_193
    val = outp32(BASE_DDR_REG+0x1002C20,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_194
    val = outp32(BASE_DDR_REG+0x1002C30,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_195
    val = outp32(BASE_DDR_REG+0x1002C40,0x00000004); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_196
    val = outp32(BASE_DDR_REG+0x1002C80,0xA88400E3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_200
    val = outp32(BASE_DDR_REG+0x1002C90,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_201
    val = outp32(BASE_DDR_REG+0x1002CA0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_202
    val = outp32(BASE_DDR_REG+0x1002CB0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_203
    val = outp32(BASE_DDR_REG+0x1002CC0,0x00000000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_204
    val = outp32(BASE_DDR_REG+0x1002D00,0xA88400D3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_208
    val = outp32(BASE_DDR_REG+0x1002D10,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_209
    val = outp32(BASE_DDR_REG+0x1002D20,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_210
    val = outp32(BASE_DDR_REG+0x1002D30,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_211
    val = outp32(BASE_DDR_REG+0x1002D40,0x00000000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_212
    val = outp32(BASE_DDR_REG+0x1002D80,0xD0EFF8E3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_216
    val = outp32(BASE_DDR_REG+0x1002D90,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_217
    val = outp32(BASE_DDR_REG+0x1002DA0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_218
    val = outp32(BASE_DDR_REG+0x1002DB0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_219
    val = outp32(BASE_DDR_REG+0x1002DC0,0x00000000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_220
    val = outp32(BASE_DDR_REG+0x1002E00,0xD0EFF8D3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_224
    val = outp32(BASE_DDR_REG+0x1002E10,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_225
    val = outp32(BASE_DDR_REG+0x1002E20,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_226
    val = outp32(BASE_DDR_REG+0x1002E30,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_227
    val = outp32(BASE_DDR_REG+0x1002E40,0x00000000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_228
    val = outp32(BASE_DDR_REG+0x1002E80,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_232
    val = outp32(BASE_DDR_REG+0x1002E90,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_233
    val = outp32(BASE_DDR_REG+0x1002EA0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_234
    val = outp32(BASE_DDR_REG+0x1002EB0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_235
    val = outp32(BASE_DDR_REG+0x1002EC0,0x00000004); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_236
    val = outp32(BASE_DDR_REG+0x1002F00,0xA08000E3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_240
    val = outp32(BASE_DDR_REG+0x1002F10,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_241
    val = outp32(BASE_DDR_REG+0x1002F20,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_242
    val = outp32(BASE_DDR_REG+0x1002F30,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_243
    val = outp32(BASE_DDR_REG+0x1002F40,0x00000000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_244
    val = outp32(BASE_DDR_REG+0x1002F80,0xA08000D3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_248
    val = outp32(BASE_DDR_REG+0x1002F90,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_249
    val = outp32(BASE_DDR_REG+0x1002FA0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_250
    val = outp32(BASE_DDR_REG+0x1002FB0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_251
    val = outp32(BASE_DDR_REG+0x1002FC0,0x00000000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_252
    val = outp32(BASE_DDR_REG+0x1003000,0xD8EBF8E3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_256
    val = outp32(BASE_DDR_REG+0x1003010,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_257
    val = outp32(BASE_DDR_REG+0x1003020,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_258
    val = outp32(BASE_DDR_REG+0x1003030,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_259
    val = outp32(BASE_DDR_REG+0x1003040,0x00000000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_260
    val = outp32(BASE_DDR_REG+0x1003080,0xD8EBF8D3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_264
    val = outp32(BASE_DDR_REG+0x1003090,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_265
    val = outp32(BASE_DDR_REG+0x10030A0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_266
    val = outp32(BASE_DDR_REG+0x10030B0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_267
    val = outp32(BASE_DDR_REG+0x10030C0,0x00000000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_268
    val = outp32(BASE_DDR_REG+0x1003100,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_272
    val = outp32(BASE_DDR_REG+0x1003110,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_273
    val = outp32(BASE_DDR_REG+0x1003120,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_274
    val = outp32(BASE_DDR_REG+0x1003130,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_275
    val = outp32(BASE_DDR_REG+0x1003140,0x00000004); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_276
    val = outp32(BASE_DDR_REG+0x1003180,0x908000E3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_280
    val = outp32(BASE_DDR_REG+0x1003190,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_281
    val = outp32(BASE_DDR_REG+0x10031A0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_282
    val = outp32(BASE_DDR_REG+0x10031B0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_283
    val = outp32(BASE_DDR_REG+0x10031C0,0x00000000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_284
    val = outp32(BASE_DDR_REG+0x1003200,0x908000D3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_288
    val = outp32(BASE_DDR_REG+0x1003210,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_289
    val = outp32(BASE_DDR_REG+0x1003220,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_290
    val = outp32(BASE_DDR_REG+0x1003230,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_291
    val = outp32(BASE_DDR_REG+0x1003240,0x00000000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_292
    val = outp32(BASE_DDR_REG+0x1003280,0xE8EBF8E3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_296
    val = outp32(BASE_DDR_REG+0x1003290,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_297
    val = outp32(BASE_DDR_REG+0x10032A0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_298
    val = outp32(BASE_DDR_REG+0x10032B0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_299
    val = outp32(BASE_DDR_REG+0x10032C0,0x00000000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_300
    val = outp32(BASE_DDR_REG+0x1003300,0xE8EBF8D3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_304
    val = outp32(BASE_DDR_REG+0x1003310,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_305
    val = outp32(BASE_DDR_REG+0x1003320,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_306
    val = outp32(BASE_DDR_REG+0x1003330,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_307
    val = outp32(BASE_DDR_REG+0x1003340,0x00000000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_308
    val = outp32(BASE_DDR_REG+0x1003380,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_312
    val = outp32(BASE_DDR_REG+0x1003390,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_313
    val = outp32(BASE_DDR_REG+0x10033A0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_314
    val = outp32(BASE_DDR_REG+0x10033B0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_315
    val = outp32(BASE_DDR_REG+0x10033C0,0x00000004); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_316
    val = outp32(BASE_DDR_REG+0x1003400,0x888000E3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_320
    val = outp32(BASE_DDR_REG+0x1003410,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_321
    val = outp32(BASE_DDR_REG+0x1003420,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_322
    val = outp32(BASE_DDR_REG+0x1003430,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_323
    val = outp32(BASE_DDR_REG+0x1003440,0x00000000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_324
    val = outp32(BASE_DDR_REG+0x1003480,0x888000D3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_328
    val = outp32(BASE_DDR_REG+0x1003490,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_329
    val = outp32(BASE_DDR_REG+0x10034A0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_330
    val = outp32(BASE_DDR_REG+0x10034B0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_331
    val = outp32(BASE_DDR_REG+0x10034C0,0x00000000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_332
    val = outp32(BASE_DDR_REG+0x1003500,0xF0EBF8E3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_336
    val = outp32(BASE_DDR_REG+0x1003510,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_337
    val = outp32(BASE_DDR_REG+0x1003520,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_338
    val = outp32(BASE_DDR_REG+0x1003530,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_339
    val = outp32(BASE_DDR_REG+0x1003540,0x00000000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_340
    val = outp32(BASE_DDR_REG+0x1003580,0xF0EBF8D3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_344
    val = outp32(BASE_DDR_REG+0x1003590,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_345
    val = outp32(BASE_DDR_REG+0x10035A0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_346
    val = outp32(BASE_DDR_REG+0x10035B0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_347
    val = outp32(BASE_DDR_REG+0x10035C0,0x00000000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_348
    val = outp32(BASE_DDR_REG+0x1003600,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_352
    val = outp32(BASE_DDR_REG+0x1003610,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_353
    val = outp32(BASE_DDR_REG+0x1003620,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_354
    val = outp32(BASE_DDR_REG+0x1003630,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_355
    val = outp32(BASE_DDR_REG+0x1003640,0x00000004); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_356
    val = outp32(BASE_DDR_REG+0x1003680,0x808004E3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_360
    val = outp32(BASE_DDR_REG+0x1003690,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_361
    val = outp32(BASE_DDR_REG+0x10036A0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_362
    val = outp32(BASE_DDR_REG+0x10036B0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_363
    val = outp32(BASE_DDR_REG+0x10036C0,0x00000000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_364
    val = outp32(BASE_DDR_REG+0x1003700,0x808004D3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_368
    val = outp32(BASE_DDR_REG+0x1003710,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_369
    val = outp32(BASE_DDR_REG+0x1003720,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_370
    val = outp32(BASE_DDR_REG+0x1003730,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_371
    val = outp32(BASE_DDR_REG+0x1003740,0x00000000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_372
    val = outp32(BASE_DDR_REG+0x1003780,0xF8EBFCE3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_376
    val = outp32(BASE_DDR_REG+0x1003790,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_377
    val = outp32(BASE_DDR_REG+0x10037A0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_378
    val = outp32(BASE_DDR_REG+0x10037B0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_379
    val = outp32(BASE_DDR_REG+0x10037C0,0x00000000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_380
    val = outp32(BASE_DDR_REG+0x1003800,0xF8EBFCD3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_384
    val = outp32(BASE_DDR_REG+0x1003810,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_385
    val = outp32(BASE_DDR_REG+0x1003820,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_386
    val = outp32(BASE_DDR_REG+0x1003830,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_387
    val = outp32(BASE_DDR_REG+0x1003840,0x00000000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_388
    val = outp32(BASE_DDR_REG+0x1003880,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_392
    val = outp32(BASE_DDR_REG+0x1003890,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_393
    val = outp32(BASE_DDR_REG+0x10038A0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_394
    val = outp32(BASE_DDR_REG+0x10038B0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_395
    val = outp32(BASE_DDR_REG+0x10038C0,0x0000000C); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_396
    val = outp32(BASE_DDR_REG+0x1003900,0x868400C3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_400
    val = outp32(BASE_DDR_REG+0x1003910,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_401
    val = outp32(BASE_DDR_REG+0x1003920,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_402
    val = outp32(BASE_DDR_REG+0x1003930,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_403
    val = outp32(BASE_DDR_REG+0x1003940,0x00000000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_404
    val = outp32(BASE_DDR_REG+0x1003980,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_408
    val = outp32(BASE_DDR_REG+0x1003990,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_409
    val = outp32(BASE_DDR_REG+0x10039A0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_410
    val = outp32(BASE_DDR_REG+0x10039B0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_411
    val = outp32(BASE_DDR_REG+0x10039C0,0x00000200); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_412
    val = outp32(BASE_DDR_REG+0x1003A00,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_416
    val = outp32(BASE_DDR_REG+0x1003A10,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_417
    val = outp32(BASE_DDR_REG+0x1003A20,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_418
    val = outp32(BASE_DDR_REG+0x1003A30,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_419
    val = outp32(BASE_DDR_REG+0x1003A40,0x00080000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_420
    val = outp32(BASE_DDR_REG+0x020204,0x0F000200); //DDR_MANUAL_CKE
    val = outp32(BASE_DDR_REG+0x020204,0x0F000000); //DDR_MANUAL_CKE
    val = inp32(BASE_DDR_REG+0x000240); //DDR_DFI_CMD_0 until get 0x00000000
    val = outp32(BASE_DDR_REG+0x000240,0x00000100); //DDR_DFI_CMD_0
    val = inp32(BASE_DDR_REG+0x00031C); //DDR_DFI_STATUS_2 until get 0x08000000
    while((val&0x8000000)==0){
        val = inp32(BASE_DDR_REG+0x00031C); //DDR_DFI_STATUS_2 until get 0x08000000
    }
    val = inp32(BASE_DDR_REG+0x000240); //DDR_DFI_CMD_0 until get 0x00000100
    val = outp32(BASE_DDR_REG+0x000240,0x00000000); //DDR_DFI_CMD_0
    val = outp32(BASE_DDR_REG+0x1002000,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_0
    val = outp32(BASE_DDR_REG+0x1002010,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_1
    val = outp32(BASE_DDR_REG+0x1002020,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_2
    val = outp32(BASE_DDR_REG+0x1002030,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_3
    val = outp32(BASE_DDR_REG+0x1002040,0x0000001A); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_4
    val = outp32(BASE_DDR_REG+0x1002080,0xA80000C3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_8
    val = outp32(BASE_DDR_REG+0x1002090,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_9
    val = outp32(BASE_DDR_REG+0x10020A0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_10
    val = outp32(BASE_DDR_REG+0x10020B0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_11
    val = outp32(BASE_DDR_REG+0x10020C0,0x00000000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_12
    val = outp32(BASE_DDR_REG+0x1002100,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_16
    val = outp32(BASE_DDR_REG+0x1002110,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_17
    val = outp32(BASE_DDR_REG+0x1002120,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_18
    val = outp32(BASE_DDR_REG+0x1002130,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_19
    val = outp32(BASE_DDR_REG+0x1002140,0x00000003); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_20
    val = outp32(BASE_DDR_REG+0x1002180,0xAC8000E3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_24
    val = outp32(BASE_DDR_REG+0x1002190,0xAC8000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_25
    val = outp32(BASE_DDR_REG+0x10021A0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_26
    val = outp32(BASE_DDR_REG+0x10021B0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_27
    val = outp32(BASE_DDR_REG+0x10021C0,0x00000000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_28
    val = outp32(BASE_DDR_REG+0x1002200,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_32
    val = outp32(BASE_DDR_REG+0x1002210,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_33
    val = outp32(BASE_DDR_REG+0x1002220,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_34
    val = outp32(BASE_DDR_REG+0x1002230,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_35
    val = outp32(BASE_DDR_REG+0x1002240,0x00000002); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_36
    val = outp32(BASE_DDR_REG+0x1002280,0xAC8000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_40
    val = outp32(BASE_DDR_REG+0x1002290,0xAC8000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_41
    val = outp32(BASE_DDR_REG+0x10022A0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_42
    val = outp32(BASE_DDR_REG+0x10022B0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_43
    val = outp32(BASE_DDR_REG+0x10022C0,0x00040000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_44
    val = outp32(BASE_DDR_REG+0x1002300,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_48
    val = outp32(BASE_DDR_REG+0x1002310,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_49
    val = outp32(BASE_DDR_REG+0x1002320,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_50
    val = outp32(BASE_DDR_REG+0x1002330,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_51
    val = outp32(BASE_DDR_REG+0x1002340,0x00000002); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_52
    val = outp32(BASE_DDR_REG+0x1002380,0xAC8000E3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_56
    val = outp32(BASE_DDR_REG+0x1002390,0xAC8000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_57
    val = outp32(BASE_DDR_REG+0x10023A0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_58
    val = outp32(BASE_DDR_REG+0x10023B0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_59
    val = outp32(BASE_DDR_REG+0x10023C0,0x00000000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_60
    val = outp32(BASE_DDR_REG+0x1002400,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_64
    val = outp32(BASE_DDR_REG+0x1002410,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_65
    val = outp32(BASE_DDR_REG+0x1002420,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_66
    val = outp32(BASE_DDR_REG+0x1002430,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_67
    val = outp32(BASE_DDR_REG+0x1002440,0x00000000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_68
    val = outp32(BASE_DDR_REG+0x1002480,0xAC8008E3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_72
    val = outp32(BASE_DDR_REG+0x1002490,0xAC8008F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_73
    val = outp32(BASE_DDR_REG+0x10024A0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_74
    val = outp32(BASE_DDR_REG+0x10024B0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_75
    val = outp32(BASE_DDR_REG+0x10024C0,0x00000000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_76
    val = outp32(BASE_DDR_REG+0x1002500,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_80
    val = outp32(BASE_DDR_REG+0x1002510,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_81
    val = outp32(BASE_DDR_REG+0x1002520,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_82
    val = outp32(BASE_DDR_REG+0x1002530,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_83
    val = outp32(BASE_DDR_REG+0x1002540,0x00000000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_84
    val = outp32(BASE_DDR_REG+0x1002580,0xAC8010E3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_88
    val = outp32(BASE_DDR_REG+0x1002590,0xAC8010F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_89
    val = outp32(BASE_DDR_REG+0x10025A0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_90
    val = outp32(BASE_DDR_REG+0x10025B0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_91
    val = outp32(BASE_DDR_REG+0x10025C0,0x00040000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_92
    val = outp32(BASE_DDR_REG+0x1002600,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_96
    val = outp32(BASE_DDR_REG+0x1002610,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_97
    val = outp32(BASE_DDR_REG+0x1002620,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_98
    val = outp32(BASE_DDR_REG+0x1002630,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_99
    val = outp32(BASE_DDR_REG+0x1002640,0x00000000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_100
    val = outp32(BASE_DDR_REG+0x1002680,0xAC8010F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_104
    val = outp32(BASE_DDR_REG+0x1002690,0xAC8010F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_105
    val = outp32(BASE_DDR_REG+0x10026A0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_106
    val = outp32(BASE_DDR_REG+0x10026B0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_107
    val = outp32(BASE_DDR_REG+0x10026C0,0x00050000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_108
    val = outp32(BASE_DDR_REG+0x1002700,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_112
    val = outp32(BASE_DDR_REG+0x1002710,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_113
    val = outp32(BASE_DDR_REG+0x1002720,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_114
    val = outp32(BASE_DDR_REG+0x1002730,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_115
    val = outp32(BASE_DDR_REG+0x1002740,0x00000000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_116
    val = outp32(BASE_DDR_REG+0x1002780,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_120
    val = outp32(BASE_DDR_REG+0x1002790,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_121
    val = outp32(BASE_DDR_REG+0x10027A0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_122
    val = outp32(BASE_DDR_REG+0x10027B0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_123
    val = outp32(BASE_DDR_REG+0x10027C0,0x00040000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_124
    val = outp32(BASE_DDR_REG+0x1002800,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_128
    val = outp32(BASE_DDR_REG+0x1002810,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_129
    val = outp32(BASE_DDR_REG+0x1002820,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_130
    val = outp32(BASE_DDR_REG+0x1002830,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_131
    val = outp32(BASE_DDR_REG+0x1002840,0x00000003); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_132
    val = outp32(BASE_DDR_REG+0x1002880,0xAD8000E3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_136
    val = outp32(BASE_DDR_REG+0x1002890,0xAD8000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_137
    val = outp32(BASE_DDR_REG+0x10028A0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_138
    val = outp32(BASE_DDR_REG+0x10028B0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_139
    val = outp32(BASE_DDR_REG+0x10028C0,0x00000000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_140
    val = outp32(BASE_DDR_REG+0x1002900,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_144
    val = outp32(BASE_DDR_REG+0x1002910,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_145
    val = outp32(BASE_DDR_REG+0x1002920,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_146
    val = outp32(BASE_DDR_REG+0x1002930,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_147
    val = outp32(BASE_DDR_REG+0x1002940,0x00000000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_148
    val = outp32(BASE_DDR_REG+0x1002980,0xAD8008E3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_152
    val = outp32(BASE_DDR_REG+0x1002990,0xAD8008F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_153
    val = outp32(BASE_DDR_REG+0x10029A0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_154
    val = outp32(BASE_DDR_REG+0x10029B0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_155
    val = outp32(BASE_DDR_REG+0x10029C0,0x00000000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_156
    val = outp32(BASE_DDR_REG+0x1002A00,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_160
    val = outp32(BASE_DDR_REG+0x1002A10,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_161
    val = outp32(BASE_DDR_REG+0x1002A20,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_162
    val = outp32(BASE_DDR_REG+0x1002A30,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_163
    val = outp32(BASE_DDR_REG+0x1002A40,0x00000000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_164
    val = outp32(BASE_DDR_REG+0x1002A80,0xAD8010E3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_168
    val = outp32(BASE_DDR_REG+0x1002A90,0xAD8010F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_169
    val = outp32(BASE_DDR_REG+0x1002AA0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_170
    val = outp32(BASE_DDR_REG+0x1002AB0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_171
    val = outp32(BASE_DDR_REG+0x1002AC0,0x00000000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_172
    val = outp32(BASE_DDR_REG+0x1002B00,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_176
    val = outp32(BASE_DDR_REG+0x1002B10,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_177
    val = outp32(BASE_DDR_REG+0x1002B20,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_178
    val = outp32(BASE_DDR_REG+0x1002B30,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_179
    val = outp32(BASE_DDR_REG+0x1002B40,0x00000004); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_180
    val = outp32(BASE_DDR_REG+0x1002B80,0xAD8008F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_184
    val = outp32(BASE_DDR_REG+0x1002B90,0x808008F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_185
    val = outp32(BASE_DDR_REG+0x1002BA0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_186
    val = outp32(BASE_DDR_REG+0x1002BB0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_187
    val = outp32(BASE_DDR_REG+0x1002BC0,0x00030000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_188
    val = outp32(BASE_DDR_REG+0x1002C00,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_192
    val = outp32(BASE_DDR_REG+0x1002C10,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_193
    val = outp32(BASE_DDR_REG+0x1002C20,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_194
    val = outp32(BASE_DDR_REG+0x1002C30,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_195
    val = outp32(BASE_DDR_REG+0x1002C40,0x00000004); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_196
    val = outp32(BASE_DDR_REG+0x1002C80,0xAA8400C3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_200
    val = outp32(BASE_DDR_REG+0x1002C90,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_201
    val = outp32(BASE_DDR_REG+0x1002CA0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_202
    val = outp32(BASE_DDR_REG+0x1002CB0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_203
    val = outp32(BASE_DDR_REG+0x1002CC0,0x00000000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_204
    val = outp32(BASE_DDR_REG+0x1002D00,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_208
    val = outp32(BASE_DDR_REG+0x1002D10,0x808000F3); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_209
    val = outp32(BASE_DDR_REG+0x1002D20,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_210
    val = outp32(BASE_DDR_REG+0x1002D30,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_211
    val = outp32(BASE_DDR_REG+0x1002D40,0x00080000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_212
    val = outp32(BASE_DDR_REG+0x1002D80,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_216
    val = outp32(BASE_DDR_REG+0x1002D90,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_217
    val = outp32(BASE_DDR_REG+0x1002DA0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_218
    val = outp32(BASE_DDR_REG+0x1002DB0,0x000000C0); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_219
    val = outp32(BASE_DDR_REG+0x1002DC0,0x00000000); //FPGA_HAPS_PHY_PLAYBACK_ENGINE_CODE_220
    val = outp32(BASE_DDR_REG+0x1000050,0x00000017); //FPGA_HAPS_PHY_DATA_BYTE_SEL
    val = outp32(BASE_DDR_REG+0x1000000,0x000000B5); //FPGA_HAPS_PHY_GENERAL_SETUP
    val = outp32(BASE_DDR_REG+0x1000180,0x00000002); //FPGA_HAPS_PHY_AUTOTRAIN_LOOP_ADDR
    val = outp32(BASE_DDR_REG+0x1000010,0x00000001); //FPGA_HAPS_PHY_PLAYBACK_ENABLE
    val = inp32(BASE_DDR_REG+0x1000020); //FPGA_HAPS_PHY_PLAYBACK_STATUS until get 0x00000001
    while (val!=0){
        val = inp32(BASE_DDR_REG+0x1000020); //FPGA_HAPS_PHY_PLAYBACK_STATUS until get 0x00000000
    }
    val = inp32(BASE_DDR_REG+0x1000190); //FPGA_HAPS_PHY_TRAIN_STATUS until get 0x00000001
    while (val!=0x1){ //train_status
        val = inp32(BASE_DDR_REG+0x1000190); //FPGA_HAPS_PHY_TRAIN_STATUS until get 0x00000001
    }
    if(val&0x4){
        monaco_log(CRITICAL, "DQ training failed [2]\n");
    }
    if((val&0x1)==0){
        monaco_log(CRITICAL, "DQ training failed [0]\n");
    }

    val = outp32(BASE_DDR_REG+0x020204,0x0F000020); //DDR_MANUAL_CKE
    val = outp32(BASE_DDR_REG+0x020204,0x0F000000); //DDR_MANUAL_CKE
    val = outp32(BASE_DDR_REG+0x020204,0x0F000100); //DDR_MANUAL_CKE
    val = outp32(BASE_DDR_REG+0x020204,0x0F000000); //DDR_MANUAL_CKE
    val = outp32(BASE_DDR_REG+0x020204,0x0F000200); //DDR_MANUAL_CKE
    val = outp32(BASE_DDR_REG+0x020204,0x0F000000); //DDR_MANUAL_CKE
    val = outp32(BASE_DDR_REG+0x020204,0x0F000040); //DDR_MANUAL_CKE
    val = outp32(BASE_DDR_REG+0x020204,0x0F000000); //DDR_MANUAL_CKE

    val = inp32(BASE_DDR_REG+0x01030C); //DDR_RANK_AVAIL until get 0x00000003
    val = outp32(BASE_DDR_REG+0x020234,0x00000001); //CSR_CNTL
    val = inp32(BASE_DDR_REG+0x000120); //DIMM_SLOT0_CONFIG until get 0x08010301
    //val = outp32(BASE_DDR_REG+0x000120,0x18010301); //DIMM_SLOT0_CONFIG   XIN
    val = outp32(BASE_DDR_REG+0x000120,0x18000301); //DIMM_SLOT0_CONFIG  --------------------------------
    val = inp32(BASE_DDR_REG+0x020200); //DDR_MANUAL until get 0x00000000
    val = outp32(BASE_DDR_REG+0x020200,0x00000000); //DDR_MANUAL
    val = inp32(BASE_DDR_REG+0x000440); //DDR_AUTO_REF_EN until get 0x00000000
    val = outp32(BASE_DDR_REG+0x000440,0x00000003); //DDR_AUTO_REF_EN
}
int my_imc_ddr_init()
{
    mddr_drv_cfg(0);
    mddr_drv_cfg(3);

    return 0;
}
#endif

/*!****************************************************************************
*
* @par Description:
*    This function initiates the high-level initialization sequences for MDDR Memory.
*
*                                  @param
*    init_parms_ptr     Pointer to a structure that contains all the
*                       high-level configuration controls available to
*                       adjust the DDR subsystem initialization.
*
* @return
*    COM_OK if the initialization was successful, COM_ERROR otherwise.
*
******************************************************************************/
#ifdef HARVEST
unsigned int ddr_driver_init(monaco_init_t *init_parms_ptr)
{
    monaco_log(LOW,        " =============================================\n");
    monaco_log(CRITICAL,   "  Monaco Driver Version: %s\n", MONACO_DRV_VER);
    monaco_log(CRITICAL,   "  SOC Hardware Version %02u.%02u.%02u\n",
        init_parms_ptr->soc_hw_version.major_version,
        init_parms_ptr->soc_hw_version.minor_version,
        init_parms_ptr->soc_hw_version.aux_version
    );
    monaco_log(LOW,        " =============================================\n");

    // Initialize MDDR
    if (mddr_init(init_parms_ptr->mode, init_parms_ptr->soc_hw_version, &(init_parms_ptr->mddr_settings)) != COM_OK)
    {
        monaco_log(CRITICAL, "  DDR Driver Fail to Init\n");
        return COM_ERROR;
    }

    monaco_log(LOW,      " =============================================\n");
    monaco_log(CRITICAL, "  DDR Driver Init Complete\n");
    monaco_log(LOW,      " =============================================\n");

#ifdef CONFIG_PRE_HAPS
    my_imc_ddr_init();
    monaco_log(LOW,      " =============================================\n");
    monaco_log(CRITICAL, "  HAPS DDR PHY Init Complete\n");
#endif
    return COM_OK;
}
#endif

/*===========================================================================
                      FUNCTION DECLARATIONS
===========================================================================*/
void ddr_print_feature_info(monaco_init_t *init_parms_ptr);
void ddr_print_error_info(void);
void get_channels_pair(void);
static void ddr_init_smbus_transfer(
        SmbusTransfer *xfer,
        uint32_t       slave_addr,
        uint32_t       command,
        I2cBuffDesc   *buffDesc,
        uint8_t       *buff,
        uint32_t       size,
        I2cIoResult   *res
)
{
    buffDesc->pBuff = buff;
    buffDesc->uBuffSize = size;
#ifdef HARVEST
    xfer->clientCfg.uBusFreqKhz            = 100;
    xfer->clientCfg.uByteTransferTimeoutUs = 25* 1000;
#endif
    xfer->tranCfg.uSlaveAddr               = slave_addr;
    xfer->command                          = command;
    xfer->pBuff                            = buffDesc;
    xfer->uTrSize                          = size;
    xfer->pIoRes                           = res;
    xfer->bBlockReadStartsWithLength       = false;
    xfer->bPecCheck                        = false;
}
static int ddr_smbus_func_at_page(
        SmbusOpFunction func,
        SmbusDevice     device,
        uint32_t        page,
        SmbusTransfer  *xfer
)
{
    SmbusResult smbRes;
    int result = set_spd_page(device, page);
    if (0 != result) return result;
    smbRes = func(device, xfer);
    return (SMBUS_SUCCESS == smbRes) ? 0 : (-EFAULT);
}

bool XBLInRecovery (void)
{
    return false;
}

/* ============================================================================
**  Function : monaco_initialize_target
** ============================================================================
*/
/*!
*   @brief
*   This function will setup the DDR, L3 Caches, and Monaco Ring Switches
*
*   @details
*   This function will pass the first parameter to the MonacoLib driver which
*   takes care of the actual initialize of the DDR, L3 Catches, and Monaco Ring
*   Switches
*
*   @param monaco_cfg__ptr   -  [IN] A pointer to configuration info for the
*                                    DDR, L3 Caches, and Monaco Ring Switches
*
*   @par Dependencies
*   None
*
*   @par Side Effects
*   None
*
*   @retval DDR_STATUS_SUCCESS or DDR failure code
*
*   @sa None
*/

int monaco_initialize_target(monaco_init_t* monaco_init_ptr, bool cold_boot)
{
    int status = 0x0;
    monaco_init_t *init_params = monaco_init_ptr;

    // Read platform ID from TSCR_SPARE3 register. Currently, we are the only
    // driver that needs this information, so we implement platform detection
    // ourselves instead of in XBL.
    init_params->mode = get_platform_id();
    switch (init_params->mode)
    {
        // PARAMETERS THAT CHANGED BASED ON THE PLATFORM
        case SILICON:
            ddr_function_table.platform = XBL;

            // If the user hasn't specified a clock speed, find an appropriate default for the platform
            if(init_params->mddr_settings.mem_freq_mhz[DDR_FREQ_1] ==0)
            {
                init_params->mddr_settings.mem_freq_mhz[DDR_FREQ_1] = DDR_MAX_SPEED_RECOVERY;
            }
            if( init_params->mddr_settings.max_1dimm_freq_mhz ==0)
            {
                init_params->mddr_settings.max_1dimm_freq_mhz = DDR_MAX_SPEED_1DPC;
            }
            if( init_params->mddr_settings.max_2dimm_freq_mhz ==0)
            {
                init_params->mddr_settings.max_2dimm_freq_mhz = DDR_MAX_SPEED_2DPC;
            }

            // In recovery mode DDR frequency is limited to 800MHz
            if (XBLInRecovery())
            {
                init_params->mddr_settings.mem_freq_mhz[DDR_FREQ_1] = DDR_MAX_SPEED_RECOVERY;
            }

            break;
        case PALLADIUM_Z1:
            ddr_function_table.platform = XBL;
            init_params->mddr_settings.mem_freq_mhz[DDR_FREQ_1] = DDR_MAX_SPEED_EMU;
            init_params->mddr_settings.mddr_xo_freq_khz = 332;
            //init_params->mddr_settings.disable_ecc = false;
            init_params->mddr_settings.disable_ecc = true;
            init_params->mddr_settings.prop_delay = 0x1F;

            break;
        case SIM:
            ddr_function_table.platform = XBL_SIM;
            init_params->mddr_settings.mem_freq_mhz[DDR_FREQ_1] = DDR_MAX_SPEED_EMU;
            init_params->mddr_settings.mddr_xo_freq_khz = 332;
            init_params->mddr_settings.disable_ecc = false;
            init_params->mddr_settings.prop_delay = 0x1F;

            break;
        case RUMI48:
            ddr_function_table.platform = XBL_RUMI;
            init_params->mddr_settings.mem_freq_mhz[DDR_FREQ_1] = DDR_MAX_SPEED_EMU;
            init_params->mddr_settings.mddr_xo_freq_khz = 332;
            init_params->mddr_settings.disable_ecc = false;
            init_params->mddr_settings.prop_delay = 0x1F;

            break;
        case RUMI42:
        default:
            // Default to SUFI to be consistent with legacy behavior
            ddr_function_table.platform = XBL_SUFI;
            init_params->mddr_settings.mem_freq_mhz[DDR_FREQ_1] = DDR_MAX_SPEED_EMU;
            init_params->mddr_settings.mddr_xo_freq_khz = 332;
            init_params->mddr_settings.disable_ecc = false;
            init_params->mddr_settings.prop_delay = 0x1F;

            break;
    }


    // Initialize register logging with partial goods information
    if(0 != log_registers_init(init_params->goods.l3_interleaves, 0x3F))
    {
        status = DDR_STATUS_FAILURE;
    }
    else
    {
        if(init_params->mode != SIM)
        {
            //We cold the reinitialization API if this is not a cold boot
            //if(cold_boot)
            {
                status = ddr_driver_init(init_params);
            }
            //else
            {
                //status = monaco_wd_reset_reinit(init_params);
            }
            // Print out summary of DDR feature
            ddr_print_feature_info(init_params);
        }
        else
        {
            status = COM_OK;
        }

        if(status != COM_OK)
        {
            // monaco_initialize_target didn't return COM_OK
            // so propagate this error upward
            status = DDR_STATUS_FAILURE;
            ddr_print_error_info();
        }
        else
        {
            // Store the physical memory controller to channel assignments in the single instance parameters
            get_channels_pair();
            status = DDR_STATUS_SUCCESS;
        }
    }

    return status;
}

/* ============================================================================
**  Function : monaco_margin_init_target
** ============================================================================
*/
/*!
*   @brief
*   This function will setup the DDR
*
*   @details
*   This function will pass the first parameter to the MonacoLib driver which
*   takes care of the actual initialize of the DDR. this is specialized for
*   DDR margining mode.
*
*   @param monaco_cfg__ptr   -  [IN] A pointer to configuration info for DDR
*
*   @par Dependencies
*   None
*
*   @par Side Effects
*   None
*
*   @retval DDR_STATUS_SUCCESS or DDR failure code
*
*   @sa None
*/

int monaco_margin_init_target(monaco_init_t* init_params)
{
    int status;
    int ret;

    init_params->mode = get_platform_id();

    //Force disable DDR self refresh, scrub and ECC
    init_params->mddr_settings.auto_self_refresh_en=false;
    init_params->mddr_settings.auto_power_down_en=false;
    init_params->mddr_settings.disable_patrol_scrub=true;
    init_params->mddr_settings.disable_ecc = true;
    init_params->mddr_settings.ca_parity = CA_PARITY_DISABLE;
    init_params->mddr_settings.dfi_lp_mode = DFI_LP_DISABLED;

    // Setup global verbosity
    log_level = init_params->log_level;

    // Initialize access to the DIMMs SPD
    spd_init(init_params->mode, init_params->spd_smbus_info);

    // Initialize MDDR
    status = mddr_margining_init(init_params->mode, init_params->soc_hw_version, &(init_params->mddr_settings));

    if(status != COM_OK)
    {
        ret = DDR_STATUS_FAILURE;
    }
    else
    {
        ret = DDR_STATUS_SUCCESS;
    }

    return ret;
}


/* ============================================================================
**  Function : monaco_get_memory_info
** ============================================================================
*/
/*!
*   @brief
*   This function will return a structure with basic memory subsystem information.
*
*   @details
*   This function will return a structure with basic memory subsystem information.
*
*   @par Dependencies
*   None
*
*   @par Side Effects
*   None
*
*   @retval  None
*
*   @sa None
*/
monaco_memory_info_t monaco_get_memory_info()
{
    mddr_cfg_t mddr_cfg;
    uint32_t ddr_size_mb = 0;
    uint8_t channel;
    monaco_memory_info_t mem_info;
    target_mode_e mode = get_platform_id();

    if(mode != SIM)
    {
        mddr_get_cfg_info(&mddr_cfg);

        for(channel = 0; channel < mddr_cfg.num_chans_supported; channel++)
        {
            ddr_size_mb += mddr_cfg.chan_cfg[channel].mem_size_gb << 10;
        }

        mem_info.ddr_region_size = ddr_size_mb;
    }
    else
    {
        mem_info.ddr_region_size = 786432;
    }

    mem_info.base_ddr_address = DDR_REGION_BASE_ADDRESS;
    mem_info.ddr_region_attributes = SYSTEM_MEMORY_RESOURCE_ATTR_CAPABILITIES;

    return mem_info;
}

/* ============================================================================
**  Function : get_silicon_revision
** ============================================================================
*/
/*!
*   @brief
*   This function will return a revision number of QDF2432 SoC
*
*   @details
*   This function will return a revision number of QDF2432 SoC
*
*   @par Dependencies
*   None
*
*   @par Side Effects
*   None
*
*   @retval  None
*
*   @sa None
*/
int get_silicon_revision(void)
{
    return ((HWIO_JTAG_ID_IN(SECURITY_CONTROL_CORE_REG_BASE) >> SILICON_REVISION_SHFT) & SILICON_REVISION_MASK);
}

/* ============================================================================
**  Function : get_spd_smbios_information
** ============================================================================
*/
/*!
*   @brief
*   This function will return DIMM information used to populate the SMBIOS tables.
*
*   @details
*   This function takes a pointer to an array of SPD info structures and fills
*   it out with the information read from the DIMM SPDs.
*
*   @par Dependencies
*   None
*
*   @par Side Effects
*   None
*
*   @retval  None
*
*   @sa None
*/
int get_spd_smbios_information(spd_info_per_dimm* spd_info_array, size_t array_size)
{

    uint8_t channel, logical_ch, dimm, available_freq_len;
    spd_dimm_config_t mddr_dimm_config;
    uint32_t available_freq_list[DDR_FREQ_ID_MAX];

    if(array_size < (sizeof(spd_info_per_dimm) * DDR_MAX_NUM_CHANS * DDR_MAX_NUM_SLOTS_PER_CHAN))
    {
        return DDR_STATUS_NO_MEMORY;
    }
    else if(spd_info_array == NULL)
    {
        // Array size is big enough
        return DDR_INVALID_PARAMETER;
    }

    // Zero out the output memory
    memset(spd_info_array, 0, array_size);

    // Get the current frequency
    available_freq_len = mddr_get_freq_map(available_freq_list);

    for(logical_ch = 0; logical_ch < DDR_MAX_NUM_CHANS; logical_ch++)
    {
        channel = ddr_logical_to_physical_channel(logical_ch);
        for(dimm = 0; dimm < DDR_MAX_NUM_SLOTS_PER_CHAN; dimm++)
        {
            mddr_get_dimm_spd_info(logical_ch, dimm, &mddr_dimm_config);
            spd_info_array[channel * 2 + dimm].device_set = channel;
            spd_info_array[channel * 2 + dimm].device_locator = channel * 2 + dimm;
            spd_info_array[channel * 2 + dimm].bank_locator = dimm;
            if(mddr_dimm_config.dev_type == SPD_DEVICE_TYPE_UNDEFINED)
            {
                spd_info_array[channel * 2 + dimm].populated = false;
            }
            else
            {
                spd_info_array[channel * 2 + dimm].populated = true;
                spd_info_array[channel * 2 + dimm].total_width = mddr_dimm_config.has_ecc ? mddr_dimm_config.dimm_module_width + 8 : mddr_dimm_config.dimm_module_width;
                spd_info_array[channel * 2 + dimm].data_width = mddr_dimm_config.dimm_module_width;
                spd_info_array[channel * 2 + dimm].memory_size = mddr_dimm_config.dimm_size_mb;
                spd_info_array[channel * 2 + dimm].form_factor = mddr_dimm_config.mod_type;
                spd_info_array[channel * 2 + dimm].memory_type = mddr_dimm_config.dev_type;
                spd_info_array[channel * 2 + dimm].type_detail = mddr_dimm_config.type_detail;
                spd_info_array[channel * 2 + dimm].max_clk_speed = mddr_dimm_config.max_clk_speed;
                spd_info_array[channel * 2 + dimm].manufacturer_id = mddr_dimm_config.manufacturer_id;
                spd_info_array[channel * 2 + dimm].serial_number = mddr_dimm_config.serial_number;
                memcpy(spd_info_array[channel * 2 + dimm].part_number, mddr_dimm_config.part_number, 20);
                spd_info_array[channel * 2 + dimm].attributes = 0xF & mddr_dimm_config.num_ranks;
                spd_info_array[channel * 2 + dimm].configured_clk_speed = available_freq_list[DDR_FREQ_1];
            }
        }
    }

    return DDR_STATUS_SUCCESS;
}


/* ============================================================================
**  Function : get_thermal_info
** ===========================================================================*/
void get_thermal_info(ddr_thermal_info* thermal_info)
{
    mddr_dimm_therm_t dimm_therm;
    uint8_t channel, logical_ch, dimm;

    // Log memory registers pre-state change
    log_memory_status_registers(NULL);
    // Get the dimm temps
    mddr_get_therm_info(&dimm_therm);
    // Log memory registers post-state change
    log_memory_status_registers(NULL);

    // Copy them into the externally exposed structure
    // which is basically identical to what MonacoLib exposes
    for(logical_ch = 0; logical_ch < DDR_MAX_NUM_CHANS; logical_ch++)
    {
        channel = ddr_logical_to_physical_channel(logical_ch);
        for(dimm = 0; dimm < DDR_MAX_NUM_SLOTS_PER_CHAN; dimm++)
        {
            thermal_info->dimm_temps[channel][dimm] = dimm_therm.dimm_temps[logical_ch][dimm];
            thermal_info->dimm_temp_event[channel][dimm] = dimm_therm.dimm_eventn_asserted[logical_ch][dimm];
            if(thermal_info->dimm_temps[channel][dimm] != MDDR_DIMM_TEMP_INVALID)
            {
                // Drop the fractional bits from the DIMM temperatures for now
                thermal_info->dimm_temps[channel][dimm] = thermal_info->dimm_temps[channel][dimm] >> 4;
            }
        }
    }
    return;
}

/* ============================================================================
**  Function : enable_thermal_mitigation
** ===========================================================================*/
void enable_thermal_mitigation(uint8_t perf_percentage)
{
}

/* ============================================================================
**  Function : disable_thermal_mitigation
** ===========================================================================*/
void disable_thermal_mitigation()
{
    // Log memory registers pre-state change
    log_memory_status_registers(NULL);
    mddr_therm_throttle_disable();
    // Log memory registers post-state change
    log_memory_status_registers(NULL);
}

/* ============================================================================
**  Function : enter_self_refresh_all
** ===========================================================================*/
void enter_self_refresh_all()
{
    // Log memory registers pre-state change
    log_memory_status_registers(NULL);
    mddr_enter_self_refresh();
    // Log memory registers post-state change
    log_memory_status_registers(NULL);
}

/* ============================================================================
**  Function : exit_self_refresh_all
** ===========================================================================*/
void exit_self_refresh_all ()
{
    // Log memory registers pre-state change
    log_memory_status_registers(NULL);
    mddr_exit_self_refresh();
    // Log memory registers post-state change
    log_memory_status_registers(NULL);
}

/* ============================================================================
**  Function : auto_refresh_rate_adj
** ===========================================================================*/
void auto_refresh_rate_adj (
    mddr_dimm_refresh_rate_t adj_ref_dimm0,
    mddr_dimm_refresh_rate_t adj_ref_dimm1
)
{
    // Log memory registers pre-state change
    log_memory_status_registers(NULL);
    mddr_periodic_auto_refresh_adj(adj_ref_dimm0,adj_ref_dimm1);
    // Log memory registers post-state change
    log_memory_status_registers(NULL);
}

/* ============================================================================
**  Function : auto_self_refresh_enable_all
** ===========================================================================*/
void auto_self_refresh_enable_all(uint32_t idle_delay)
{
    // Log memory registers pre-state change
    log_memory_status_registers(NULL);
    mddr_auto_self_refresh_enable(idle_delay);
    // Log memory registers post-state change
    log_memory_status_registers(NULL);
}

/* ============================================================================
**  Function : auto_self_refresh_disable_all
** ===========================================================================*/
void auto_self_refresh_disable_all()
{
    // Log memory registers pre-state change
    log_memory_status_registers(NULL);
    mddr_auto_self_refresh_disable();
    // Log memory registers post-state change
    log_memory_status_registers(NULL);
}

/* ============================================================================
**  Function : auto_power_down_enable_all
** ===========================================================================*/
void auto_power_down_enable_all(uint32_t idle_delay)
{
    // Log memory registers pre-state change
    log_memory_status_registers(NULL);
    mddr_auto_self_refresh_enable(idle_delay);
    // Log memory registers post-state change
    log_memory_status_registers(NULL);
}

/* ============================================================================
**  Function : auto_power_down_disable_all
** ===========================================================================*/
void auto_power_down_disable_all()
{
    // Log memory registers pre-state change
    log_memory_status_registers(NULL);
    mddr_auto_power_down_disable();
    // Log memory registers post-state change
    log_memory_status_registers(NULL);
}

/* ============================================================================
**  Function : get_active_hdrss_instances
** ===========================================================================*/
void get_active_channels(ddr_dimm_pop_map* map)
{

    mddr_cfg_t mddr_cfg;
    uint8_t channel, dimm;

    if(map == NULL)
    {
        return;
    }

    mddr_get_cfg_info(&mddr_cfg);

    // Copy the data into the externally exposed structure
    // which is basically identical to what MonacoLib exposes
    for(channel = 0; channel < DDR_MAX_NUM_CHANS; channel++)
    {
        for(dimm = 0; dimm < DDR_MAX_NUM_SLOTS_PER_CHAN; dimm++)
        {
            map->population_map[ddr_logical_to_physical_channel(channel)][dimm] = ((mddr_cfg.chan_cfg[channel].slot_map >> dimm) & 0x1) == 1 ? true : false;
        }
    }
}

/* ============================================================================
**  Function : get_channels_pair
** ===========================================================================*/
void get_channels_pair(void)
{
    mddr_cfg_t mddr_cfg;
    uint8_t channel;

    mddr_get_cfg_info(&mddr_cfg);

    // Copy the data into the externally exposed structure
    // which is basically identical to what MonacoLib exposes
    for(channel = 0; channel < DDR_MAX_NUM_CHANS; channel++)
    {
        if(mddr_cfg.chan_cfg[channel].num_slots_populated !=0)
        {
            if((channel % 2) == 0)
            {
                //Even channel
                ddr_function_table.even_chan_insts[channel/2]=ddr_logical_to_physical_channel(channel);
            }
            else
            {
                //Odd channel
                ddr_function_table.odd_chan_insts[channel/2]=ddr_logical_to_physical_channel(channel);
            }
        }
    }

}

/* ============================================================================
**  Function : xbl_smbus_read_generic
** ===========================================================================*/
int xbl_smbus_read_generic(uint32_t smbus_id, uint32_t smb_address, uint16_t read_offset, void* out_buffer, size_t buffer_size)
{
    SmbusDevice device;
    SmbusTransfer xfer;
    I2cBuffDesc buff;
    I2cIoResult res;
    uint32_t command = read_offset % SPD_PAGE_SIZE;
    int result = 0;

    if(out_buffer == NULL)
    {
        return -EINVAL;
    }

    // Figure out which core device we need to use
    switch(smbus_id)
    {
        //BLSP0_QUP0
        case 0:
            device = SMBUS_DEVICE_1;
            break;
        case 1:
            device = SMBUS_DEVICE_2;
            break;
        default:
            return -EINVAL;
    }

    if(!SmbusIsAttached(device))
    { // Only initalize each SMBUS handle once to save memory
        if(SMBUS_SUCCESS != SmbusAttach (device)) return -EINVAL;
        // TODO: These are never getting freed, should we free these?
        // Will these get automatically reclaimed when IMC loads over Loader?
    }
    ddr_init_smbus_transfer(&xfer, smb_address, command,
            &buff, (uint8_t *)out_buffer, buffer_size, &res);

    // See if we are reading from the EEPROM
    if((smb_address & (~(SPD_ADDRESS_LSA_MASK))) == SPD_EEPROM_ADDRESS_MASK)
    {
        // If we are reading the 257th byte or greater, we need to switch the page
        // (offset is 0 indexed, so 1st byte is 0, 256th byte is offset 255, so offset 256 is the 257th byte)
        if(read_offset >= SPD_PAGE_SIZE)
        {
            // Read will truncate the offset to 8-bits, so if the offset is > SPD_PAGE_SIZE (256) then it will wrap around
            // This is okay behavior because we set the appropriate 256-byte page above
            return ddr_smbus_func_at_page(SmbusBlockRead, device, 1, &xfer);
        }
        // If this read spans pages, we will need to do a more complicated set of reads to get all of the data
        // (buffer_size is 1 indexed while offset is 0 indexed, subtract one to make everything 0 indexed)
        else if((read_offset + (buffer_size - 1)) >= SPD_PAGE_SIZE)
        {
            uint16_t page_boundary_byte_offset = SPD_PAGE_SIZE - read_offset;
            xfer.pBuff->uBuffSize = page_boundary_byte_offset;
            xfer.uTrSize          = page_boundary_byte_offset;
            // Read all the information the resides on the first page
            result = ddr_smbus_func_at_page(SmbusBlockRead, device, 0, &xfer);
            if(0 != result) return result;

            xfer.pBuff->uBuffSize = buffer_size - page_boundary_byte_offset;
            xfer.pBuff->pBuff    += page_boundary_byte_offset;
            xfer.uTrSize          = buffer_size - page_boundary_byte_offset;
            return ddr_smbus_func_at_page(SmbusBlockRead, device, 1, &xfer);
        }
        else
        {
            // All the necessary data is in page 0
            return ddr_smbus_func_at_page(SmbusBlockRead, device, 0, &xfer);
        }
    }
    else // We are reading some address other than the EEPROM
    {
        SmbusResult status;
        // Thermal sensors don't support block read functionality
        if(buffer_size == 1)
        {
            status = SmbusReadDataByte(device, &xfer);
        }
        else if (buffer_size == 2)
        {
            status = SmbusReadDataWord(device, &xfer);
        }
        else
        {
            status = SmbusBlockRead(device, &xfer);
        }
        if (SMBUS_SUCCESS == status)
        {
            return 0;
        }
        else
        {
            return -EFAULT;
        }
    }
}

/* ============================================================================
**  Function : xbl_smbus_read_data_byte
** ===========================================================================*/
int xbl_smbus_read_data_byte(uint32_t smbus_id, uint32_t smb_address, uint16_t read_offset, uint8_t* out_data)
{
    return xbl_smbus_read_generic(smbus_id, smb_address, read_offset, out_data, 1 /* 1 byte long */);
}

/* ============================================================================
**  Function : xbl_smbus_read_data_word
** ===========================================================================*/
int xbl_smbus_read_data_word(uint32_t smbus_id, uint32_t smb_address, uint16_t read_offset, uint16_t* out_data)
{
    return xbl_smbus_read_generic(smbus_id, smb_address, read_offset, out_data, 2 /* 2 byte long */);
}

/* ============================================================================
**  Function : xbl_smbus_read_cached_generic
** ===========================================================================*/
int xbl_smbus_read_cached_generic(uint32_t smbus_id, uint32_t smb_address, uint16_t read_offset, void* out_buffer, size_t buffer_size)
{
    dimm_slot_smbus_info_t *spd_info, *spd_info_ptr;
    uint8_t logic_chan=0xff;
    uint8_t logic_dimm=0xff;
    uint8_t i,j;
    void *spd_cached_ptr;

    // Get SDP SMBUS information
    spd_info = get_monaco_smbus_information();
    spd_cached_ptr = spd_cached_base;

    // Backward search DDR logical channel number from smbus id and address
    // SMBUS table is composed of in logical channel order
    for(i=0;i<DDR_MAX_NUM_CHANS;i++)
    {
        for(j=0;j<DDR_MAX_NUM_SLOTS_PER_CHAN;j++)
        {
            spd_info_ptr = spd_info+i*DDR_MAX_NUM_SLOTS_PER_CHAN +j;
            if((((dimm_slot_smbus_info_t *)spd_info_ptr)->smbus_id == smbus_id)
                && (((dimm_slot_smbus_info_t *)spd_info_ptr)->spd_eeprom_bus_addr>>1 == smb_address))
            {
                logic_chan = i;
                logic_dimm = j;
                break;
            }
        }
    }

    if(logic_chan ==0xff || logic_dimm==0xff)
    {
        // in case the channel numer not found, directly read SPD information
        return xbl_smbus_read_generic(smbus_id, smb_address, read_offset, out_buffer, buffer_size);
    }
    else
    {
        if(spd_offset[ddr_logical_to_physical_channel(logic_chan)][logic_dimm] != 0xffff)
        {
            // Copy over to monaco library from cached SPD memory
            spd_cached_ptr = spd_cached_base + sizeof(SPD_CONFIG_TABLE_HEADER) + spd_offset[ddr_logical_to_physical_channel(logic_chan)][logic_dimm] + sizeof(SPD_CONFIG_ENTRY_HEADER);
            memcpy(out_buffer, spd_cached_ptr + read_offset, buffer_size);
            return 0;
        }
        else
        {
            return -EFAULT;
        }
    }
}

/* ============================================================================
**  Function : xbl_smbus_read_cache_data_byte
** ===========================================================================*/
int xbl_smbus_read_cached_data_byte(uint32_t smbus_id, uint32_t smb_address, uint16_t read_offset, uint8_t* out_data)
{
    return xbl_smbus_read_cached_generic(smbus_id, smb_address, read_offset, out_data, 1 /* 1 byte long */);
}

/* ============================================================================
**  Function : xbl_smbus_read_cache_data_word
** ===========================================================================*/
int xbl_smbus_read_cached_data_word(uint32_t smbus_id, uint32_t smb_address, uint16_t read_offset, uint16_t* out_data)
{
    return xbl_smbus_read_cached_generic(smbus_id, smb_address, read_offset, out_data, 2 /* 2 byte long */);
}

/* ============================================================================
**  Function : xbl_smbus_write_generic
** ===========================================================================*/
int xbl_smbus_write_generic(uint32_t smbus_id, uint32_t smb_address, uint16_t write_offset, void* in_buffer, size_t buffer_size)
{
    SmbusDevice device;
    SmbusTransfer xfer;
    I2cBuffDesc buff;
    I2cIoResult res;
    uint32_t command = write_offset;
    int result = 0;

    if(in_buffer == NULL)
    {
        return -EINVAL;
    }

    // Figure out which core device we need to use
    switch(smbus_id)
    {
        //BLSP0_QUP0
        case 0:
            device = SMBUS_DEVICE_1;
            break;
        case 1:
            device = SMBUS_DEVICE_2;
            break;
        default:
            return -EINVAL;
    }


    if(!SmbusIsAttached(device))
    { // Only initalize each SMBUS handle once to save memory
        if(SMBUS_SUCCESS != SmbusAttach (device)) return -EFAULT;
        // TODO: These are never getting freed, should we free these?
        // Will these get automatically reclaimed when IMC loads over Loader?
    }
    ddr_init_smbus_transfer(&xfer, smb_address, command,
            &buff, (uint8_t *)in_buffer, buffer_size, &res);

    // See if we are reading from the EEPROM
    if((smb_address & (~(SPD_ADDRESS_LSA_MASK))) == SPD_EEPROM_ADDRESS_MASK)
    {
        // If we are writing the 257th byte or greater, we need to switch the page
        // (offset is 0 indexed, so 1st byte is 0, 256th byte is offset 255, so offset 256 is the 257th byte)
        if(write_offset >= SPD_PAGE_SIZE)
        {
            return ddr_smbus_func_at_page(SmbusBlockWrite, device, 1, &xfer);
        }
        // If this write spans pages, we will need to do a more complicated set of writes to write all of the data
        // (buffer_size is 1 indexed while offset is 0 indexed, subtract one to make everything 0 indexed)
        else if((write_offset + (buffer_size - 1)) >= SPD_PAGE_SIZE)
        {
            uint16_t page_boundary_byte_offset = SPD_PAGE_SIZE - write_offset;
            xfer.pBuff->uBuffSize = page_boundary_byte_offset;
            xfer.uTrSize          = page_boundary_byte_offset;

            // Read all the information the resides on the first page
            result = ddr_smbus_func_at_page(SmbusBlockWrite, device, 0, &xfer);
            if(0 != result) return result;

            xfer.pBuff->uBuffSize = buffer_size - page_boundary_byte_offset;
            xfer.uTrSize          = buffer_size - page_boundary_byte_offset;
            return ddr_smbus_func_at_page(SmbusBlockWrite, device, 1, &xfer);
        }
        else
        {
            return ddr_smbus_func_at_page(SmbusBlockWrite, device, 0, &xfer);
        }
    }
    else // We are writing to some address other than the EEPROM
    {
        SmbusResult status;
        if(buffer_size == 1)
        {
            status = SmbusWriteDataByte(device, &xfer);
        }
        else if (buffer_size == 2)
        {
            status = SmbusWriteDataWord(device, &xfer);
        }
        else
        {
            status = SmbusBlockWrite(device, &xfer);
        }
        if (SMBUS_SUCCESS == status)
        {
            return 0;
        }
        else
        {
            return -EFAULT;
        }
    }
}

/* ============================================================================
**  Function : xbl_smbus_write_data_byte
** ===========================================================================*/
int xbl_smbus_write_data_byte(uint32_t smbus_id, uint32_t smb_address, uint16_t write_offset, uint8_t value)
{
    uint8_t val = value;
    return xbl_smbus_write_generic(smbus_id, smb_address, write_offset, &val, sizeof(val));
}

/* ============================================================================
**  Function : xbl_smbus_write_data_word
** ===========================================================================*/
int xbl_smbus_write_data_word(uint32_t smbus_id, uint32_t smb_address, uint16_t write_offset, uint16_t value)
{
    uint16_t val = value;
    return xbl_smbus_write_generic(smbus_id, smb_address, write_offset, &val, sizeof(val));
}

/* ============================================================================
**  Function : xbl_prepare_clock_change
** ===========================================================================*/
bool xbl_prepare_clock_change(uint32_t nMDDRChannel, uint32_t nFreqKHz)
{
    return true;
}

/* ============================================================================
**  Function : xbl_apply_clock_change
** ===========================================================================*/
bool xbl_apply_clock_change(uint32_t nMDDRChannel, mddr_clk_type_t clk_type)
{
    return true;
}

/* ============================================================================
**  Function : xbl_clean_up_clock_change
** ===========================================================================*/
bool xbl_clean_up_clock_change(uint32_t nMDDRChannel)
{
    return true;
}

/* ============================================================================
**  Function : xbl_wait_us
** ===========================================================================*/
bool xbl_wait_us(uint32_t us_to_wait)
{
    udelay(us_to_wait);
    return true;
}

void boot_log_message(int level, char * message)
{
    monaco_log(level, message);
}

/* ============================================================================
**  Function : xbl_printf
** ===========================================================================*/
int xbl_printf(const char * fmt, va_list vargs)
{
    size_t str_len = 0;

    // Turn the vargs into a formatted character buffer
    vsnprintf(printf_buffer, sizeof(printf_buffer), fmt, vargs);

    // Strip off unnecessary newlines
    // The boot logger automatically terminates all printed messages with a newline
    str_len = strlen(printf_buffer);
    if(str_len > 0 && printf_buffer[str_len - 1] == '\n')
    {
        printf_buffer[str_len - 1] = 0;
    }

    // Actually log the message
    boot_log_message(CRITICAL, printf_buffer);

    return 0;
}

/* ============================================================================
**  Function : xbl_rs_bum_read_counter
** ===========================================================================*/
void xbl_rs_bum_read_counter(rs_type_e su_type, uint32_t su_id, rs_bum_cntr_t *bum_cnt)
{
    rs_read_bum_counter(su_type, su_id, bum_cnt);
}

/* ============================================================================
**  Function : xbl_ddr_bum_read_counter
** ===========================================================================*/
void xbl_ddr_bum_read_counter(mddr_bum_info_t *mddr_bum_info_ptr)
{
    mddr_get_bum_info(mddr_bum_info_ptr);
}

/* ============================================================================
**  Function : xbl_ddr_bum_read_counter
** ===========================================================================*/
void xbl_ddr_get_state_info(mddr_state_info_t* ddr_state)
{
    mddr_state_info_t mddr_state;
    uint8_t channel, logical_ch, dimm;

    if(ddr_state == NULL)
    {
        return;
    }

    get_ddr_state(&mddr_state);

    // Copy them into the externally exposed structure
    // which is basically identical to what MonacoLib exposes
    for(logical_ch = 0; logical_ch < DDR_MAX_NUM_CHANS; logical_ch++)
    {
        channel = ddr_logical_to_physical_channel(logical_ch);
        for(dimm = 0; dimm < DDR_MAX_NUM_SLOTS_PER_CHAN; dimm++)
        {
            ddr_state->dimm_in_pd[channel][dimm] = mddr_state.dimm_in_pd[logical_ch][dimm];
            ddr_state->dimm_in_sr[channel][dimm] = mddr_state.dimm_in_sr[logical_ch][dimm];
            ddr_state->dimm_ref_rate_adj[channel][dimm] = mddr_state.dimm_ref_rate_adj[logical_ch][dimm];
        }
    }
    return;

}

/* ============================================================================
**  Function : get_platform_id
** ===========================================================================*/
target_mode_e get_platform_id()
{
    target_mode_e mode;
    uint8_t platform_id = 0x00;

    // Get the platform ID
    platform_id = HWIO_INXM(TCSR_REGS_REG_BASE, SPARE3, EMULATION_PLATFORM_ID_MASK);
    switch(platform_id)
    {
        case PLATFORM_SIM:
            mode = SIM;
            break;
        case PLATFORM_RUMI_48:
            mode = RUMI48;
            break;
        case PLATFORM_SUFI_42:
            mode = RUMI42;
            break;
        case PLATFORM_SILICON:
        default:
            mode = SILICON;
            break;
    }
#ifdef CONFIG_TESTOS_EMU
        return PALLADIUM_Z1;
#else
    return mode;
#endif
}

/* ============================================================================
**  Function : set_spd_page
** ===========================================================================*/
int set_spd_page(SmbusDevice device, uint8_t page)
{
    SmbusResult status;
    SmbusTransfer xfer;
    I2cBuffDesc buff;
    I2cIoResult res;
    uint8_t read_data;
    uint8_t write_data = 0;
    uint32_t addr;

    // Make sure the parameters are sound
    if(page > 1 || device >= SMBUS_NUM_DEVICES)
    {
        return -EINVAL;
    }

    addr = SPD_SW_COMMAND_RPA_ADDR;
    // Read RPA. If NACK'd, we're on page 1. If ACK'd, we're on page 0
    ddr_init_smbus_transfer(&xfer, SPD_SW_COMMAND_RPA_ADDR, 0, &buff,
            (uint8_t *)&read_data, 1, &res);
    status = SmbusReceiveByte(device, &xfer);
    if (SMBUS_SUCCESS == status && page == 0)
    {
        return 0;
    }
    else if(SMBUS_SUCCESS != status && page == 1)
    {
        return 0;
    }

    addr = (page == 0) ? SPD_SW_COMMAND_SPA0_ADDR : SPD_SW_COMMAND_SPA1_ADDR;
    ddr_init_smbus_transfer(&xfer, addr, 0xFF, &buff,
            (uint8_t *)&write_data, 1, &res);
    status = SmbusWriteDataByte(device, &xfer);

    // Some SPD chips will NACK the data bytes when writing SPA addresses, so
    // we read the RPA address to make sure we're on the right page
    if(SMBUS_SUCCESS == status)
    {
        addr = SPD_SW_COMMAND_RPA_ADDR;
        // Read RPA. If NACK'd, we're on page 1. If ACK'd, we're on page 0
        ddr_init_smbus_transfer(&xfer, addr, 0, &buff,
                (uint8_t *)&read_data, 1, &res);
        status = SmbusReceiveByte(device, &xfer);

        if(status == SMBUS_SUCCESS && page == 1)
        {
            return -EFAULT;
        }
        else if(status != SMBUS_SUCCESS && page == 0)
        {
            return -EFAULT;
        }
    }

    return 0;
}


/* ============================================================================
**  Function : ddr_print_error_info
** ===========================================================================*/
void ddr_print_error_info()
{
#ifdef MDEPKG_NDEBUG

    uint16 ddrch;
    mddr_cfg_t mddr_cfg;
    uint64_t mddr_base_addr[6] = {
        0xFF1C000000,
        0xFF1A000000,
        0xFF04000000,
        0xFF06000000,
        0xFF0A000000,
        0xFF20000000};

    mddr_get_cfg_info(&mddr_cfg);

    for(ddrch=0;ddrch<DDR_MAX_NUM_CHANS;ddrch++)
    {
        if(mddr_cfg.chan_cfg[ddr_physical_to_logical_channel(ddrch)].num_slots_populated !=0)
        {
            monaco_log(CRITICAL, "+===========+== DDR CHANNEL %d DUMP ====+========+\n", ddrch);
            monaco_log(CRITICAL, "|ERR_STATUS |%08x\n", HWIO_D0_ERR_STATUS_IN(mddr_base_addr[ddrch]));
            monaco_log(CRITICAL, "|ERR_CAP    |%08x|%08x|%08x|%08x|"
                ,HWIO_D0_ERR_CAP_0_IN(mddr_base_addr[ddrch])
                ,HWIO_D0_ERR_CAP_1_IN(mddr_base_addr[ddrch])
                ,HWIO_D0_ERR_CAP_2_IN(mddr_base_addr[ddrch])
                ,HWIO_D0_ERR_CAP_3_IN(mddr_base_addr[ddrch]));
            monaco_log(CRITICAL, "    %08x|%08x|%08x|%08x|%08x|"
                ,HWIO_D0_ERR_CAP_4_IN(mddr_base_addr[ddrch])
                ,HWIO_D0_ERR_CAP_5_IN(mddr_base_addr[ddrch])
                ,HWIO_D0_ERR_CAP_6_IN(mddr_base_addr[ddrch])
                ,HWIO_D0_ERR_CAP_7_IN(mddr_base_addr[ddrch])
                ,HWIO_D0_ERR_CAP_8_IN(mddr_base_addr[ddrch]));
            monaco_log(CRITICAL, "    %08x|%08x|%08x|%08x|"
                ,HWIO_D0_ERR_CAP_9_IN(mddr_base_addr[ddrch])
                ,HWIO_D0_ERR_CAP_10_IN(mddr_base_addr[ddrch])
                ,HWIO_D0_ERR_CAP_11_IN(mddr_base_addr[ddrch])
                ,HWIO_D0_ERR_CAP_12_IN(mddr_base_addr[ddrch]));
            monaco_log(CRITICAL, "|DFI_STATUS |%08x|%08x|%08x\n"
                ,HWIO_D0_DDR_DFI_STATUS_0_IN(mddr_base_addr[ddrch])
                ,HWIO_D0_DDR_DFI_STATUS_1_IN(mddr_base_addr[ddrch])
                ,HWIO_D0_DDR_DFI_STATUS_2_IN(mddr_base_addr[ddrch]));
            monaco_log(CRITICAL, "|PHY_STATUS |%08x|%08x|%08x\n"
                ,HWIO_D0_DDR_PHY_STATUS_0_IN(mddr_base_addr[ddrch])
                ,HWIO_D0_DDR_PHY_STATUS_1_IN(mddr_base_addr[ddrch])
                ,HWIO_D0_DDR_PHY_STATUS_2_IN(mddr_base_addr[ddrch]));
            monaco_log(CRITICAL, "|ECC_STATUS |%08x|%08x|%08x|%08x|"
                ,HWIO_D0_ECC_CE_STATUS_0_IN(mddr_base_addr[ddrch])
                ,HWIO_D0_ECC_CE_STATUS_1_IN(mddr_base_addr[ddrch])
                ,HWIO_D0_ECC_CE_STATUS_2_IN(mddr_base_addr[ddrch])
                ,HWIO_D0_ECC_CE_STATUS_3_IN(mddr_base_addr[ddrch]));
            monaco_log(CRITICAL, "    %08x|%08x|%08x|%08x|"
                ,HWIO_D0_ECC_CE_STATUS_4_IN(mddr_base_addr[ddrch])
                ,HWIO_D0_ECC_CE_STATUS_5_IN(mddr_base_addr[ddrch])
                ,HWIO_D0_ECC_CE_STATUS_6_IN(mddr_base_addr[ddrch])
                ,HWIO_D0_ECC_CE_STATUS_7_IN(mddr_base_addr[ddrch]));
            monaco_log(CRITICAL, "|SCRUBSTATUS|%08x\n",HWIO_D0_SCRUB_STATUS_IN(mddr_base_addr[ddrch]));
            monaco_log(CRITICAL, "|CMD_STATUS |%08x\n",HWIO_D0_DDR_CMD_STATUS_IN(mddr_base_addr[ddrch]));
            monaco_log(CRITICAL, "|INTERSTATUS|%08x\n",HWIO_D0_DDR_INTERNAL_STATUS_0_IN(mddr_base_addr[ddrch]));
            monaco_log(CRITICAL, "|DIMM TECH  |%08x\n",HWIO_D0_DIMM_TECH_IN(mddr_base_addr[ddrch]));
            monaco_log(CRITICAL, "|ADDR_DECODE|%08x\n",HWIO_D0_ADDR_DECODE_CNTL_IN(mddr_base_addr[ddrch]));
            monaco_log(CRITICAL, "|SLOT CONFIG|%08x|%08x\n"
                ,HWIO_D0_DIMM_SLOT0_CONFIG_IN(mddr_base_addr[ddrch])
                ,HWIO_D0_DIMM_SLOT1_CONFIG_IN(mddr_base_addr[ddrch]));
            monaco_log(CRITICAL, "|DEVICESTATE|%08x\n",HWIO_D0_DDR_DEVICE_STATE_IN(mddr_base_addr[ddrch]));
            monaco_log(CRITICAL, "|DDRIDLEPCHG|%08x\n",HWIO_D0_DDR_IDLE_STATUS_PCHG_IN(mddr_base_addr[ddrch]));
            monaco_log(CRITICAL, "|DDRIDLE_ACT|%08x\n",HWIO_D0_DDR_IDLE_STATUS_ACT_IN(mddr_base_addr[ddrch]));
            monaco_log(CRITICAL, "|DATAFLWCNTL|%08x\n",HWIO_D0_DATAFLOW_CNTL_IN(mddr_base_addr[ddrch]));
            monaco_log(CRITICAL, "|DATAFLWCDE |%08x|%08x|%08x|%08x|\n"
                ,HWIO_D0_DATAFLOW_CDE_CNTL_0_IN(mddr_base_addr[ddrch])
                ,HWIO_D0_DATAFLOW_CDE_CNTL_1_IN(mddr_base_addr[ddrch])
                ,HWIO_D0_DATAFLOW_CDE_CNTL_2_IN(mddr_base_addr[ddrch])
                ,HWIO_D0_DATAFLOW_CDE_CNTL_3_IN(mddr_base_addr[ddrch]));
            monaco_log(CRITICAL, "    %08x|%08x|%08x"
                ,HWIO_D0_DATAFLOW_CDE_CNTL_4_IN(mddr_base_addr[ddrch])
                ,HWIO_D0_DATAFLOW_CDE_CNTL_5_IN(mddr_base_addr[ddrch])
                ,HWIO_D0_DATAFLOW_CDE_CNTL_6_IN(mddr_base_addr[ddrch]));
            monaco_log(CRITICAL, "|CABUS_CNTL |%08x\n",HWIO_D0_DDR_CA_BUS_CNTL_IN(mddr_base_addr[ddrch]));
            monaco_log(CRITICAL, "|DQBUS_CNTL |%08x\n",HWIO_D0_DDR_DQ_BUS_CNTL_IN(mddr_base_addr[ddrch]));
            monaco_log(CRITICAL, "|ASR_EN     |%08x\n",HWIO_D0_DDR_AUTO_REF_EN_IN(mddr_base_addr[ddrch]));
            monaco_log(CRITICAL, "|ASR_CNTL   |%08x\n",HWIO_D0_DDR_AUTO_REF_CNTL_IN(mddr_base_addr[ddrch]));
            monaco_log(CRITICAL, "|PWRDN_CNTL |%08x\n",HWIO_D0_DDR_PWR_DOWN_CNTL_IN(mddr_base_addr[ddrch]));
            monaco_log(CRITICAL, "|SELFREFCNTL|%08x\n",HWIO_D0_DDR_SELF_REF_CNTL_IN(mddr_base_addr[ddrch]));
            monaco_log(CRITICAL, "|ZQCAL_EN   |%08x\n",HWIO_D0_DDR_ZQCAL_EN_IN(mddr_base_addr[ddrch]));
            monaco_log(CRITICAL, "|ZQCAL_CNTL |%08x\n",HWIO_D0_DDR_ZQCAL_CNTL_IN(mddr_base_addr[ddrch]));
            monaco_log(CRITICAL, "|ODT WR CNTL|%08x\n",HWIO_D0_DDR_ODT_WR_CNTL_IN(mddr_base_addr[ddrch]));
            monaco_log(CRITICAL, "|ODT RD CNTL|%08x\n",HWIO_D0_DDR_ODT_RD_CNTL_IN(mddr_base_addr[ddrch]));
            monaco_log(CRITICAL, "+===========+========+========+========+========+\n");
        }
    }
#endif// MDEPKG_NDEBUG
}


/* ============================================================================
**  Function : ddr_print_feature_info
** ===========================================================================*/
volatile uint64_t ddr_real_size;
void ddr_print_feature_info(monaco_init_t *init_parms_ptr)
{
    monaco_memory_info_t mddr_info;
#define STR_ON              "On"
#define STR_OFF             "Off"

    monaco_log(CRITICAL, "+=========== BOOT VARIABLE CONFIGURATION ===========+\n");

    mddr_info = monaco_get_memory_info();
    ddr_real_size = mddr_info.ddr_region_size;
    monaco_log(CRITICAL, "| Total Available Memory:%luMB, Speed:%luMhz\n", mddr_info.ddr_region_size,init_parms_ptr->mddr_settings.mem_freq_mhz[DDR_FREQ_1]);

    monaco_log(CRITICAL, "|GRANULE:%s  DIMM INTRLV:%s  SCRAMBLE:%s\n"
        ,(init_parms_ptr->mddr_settings.ddr_granule==DDR_DIST_GRANULE_256B)?"256B":
        ((init_parms_ptr->mddr_settings.ddr_granule==DDR_DIST_GRANULE_4KB)?"4KB":
        ((init_parms_ptr->mddr_settings.ddr_granule==DDR_DIST_GRANULE_8KB)?"8KB":"?"))
        ,init_parms_ptr->mddr_settings.dimm_intlv_en?STR_ON:STR_OFF
        ,init_parms_ptr->mddr_settings.mddr_scrambling_en?STR_ON:STR_OFF);

    monaco_log(CRITICAL, "|CA_PARITY:%s  DBI:%s  2T:%s  CA STRETCH:%s\n"
        ,(init_parms_ptr->mddr_settings.ca_parity==CA_PARITY_DRAM_DIMM)?"DRAMDIMM":
        ((init_parms_ptr->mddr_settings.ca_parity==CA_PARITY_DIMM)?"DIMM":
        ((init_parms_ptr->mddr_settings.ca_parity==CA_PARITY_DRAM)?"DRAM":
        ((init_parms_ptr->mddr_settings.ca_parity==CA_PARITY_DISABLE)?"DIS":"?")))
        ,(init_parms_ptr->mddr_settings.dbi_mode==DDR_DBI_READ_WRITE)?"RW":
        ((init_parms_ptr->mddr_settings.dbi_mode==DDR_DBI_WRITE)?"WRITE":
        ((init_parms_ptr->mddr_settings.dbi_mode==DDR_DBI_READ)?"READ":
        ((init_parms_ptr->mddr_settings.dbi_mode==DDR_DBI_OFF)?"DIS":"?")))
        ,(init_parms_ptr->mddr_settings.ddr4_2t_preamble_mode==DDR4_2T_WRITE_READ)?"RW":
        ((init_parms_ptr->mddr_settings.ddr4_2t_preamble_mode==DDR4_2T_WRITE)?"WRITE":
        ((init_parms_ptr->mddr_settings.ddr4_2t_preamble_mode==DDR4_2T_READ)?"READ":
        ((init_parms_ptr->mddr_settings.ddr4_2t_preamble_mode==DDR4_2T_DISABLE)?"DIS":"?")))
        ,(init_parms_ptr->mddr_settings.ca_stretch==CA_STRETCH_1T)?"1T":
        ((init_parms_ptr->mddr_settings.ca_stretch==CA_STRETCH_2T)?"2T":
        ((init_parms_ptr->mddr_settings.ca_stretch==CA_STRETCH_3T)?"3T":
        ((init_parms_ptr->mddr_settings.ca_stretch==CA_STRETCH_4T)?"4T":"?"))));

    monaco_log(HIGH, "|THERMTHROT:%s  ADDR:%s\n"
        ,init_parms_ptr->mddr_settings.therm_throttle_en?STR_ON:STR_OFF
        ,(init_parms_ptr->mddr_settings.bank_group_decode==ADDR_DECODE_BG_MCA_16_15)?"MCA_16_15":
        ((init_parms_ptr->mddr_settings.bank_group_decode==ADDR_DECODE_BG_MCA_8_7)?"MCA_8_7":
        ((init_parms_ptr->mddr_settings.bank_group_decode==ADDR_DECODE_BG_MCA_16_7)?"MCA_16_7":
        ((init_parms_ptr->mddr_settings.bank_group_decode==ADDR_DECODE_BG_R_C_RK_B_BG)?"RCRKBG":"?"))));

    monaco_log(HIGH, "|OVERCLOCK:%s  ZQCAL:%s  PROP_DELAY:%d\n"
        ,init_parms_ptr->mddr_settings.allow_overclocking?STR_ON:STR_OFF
        ,init_parms_ptr->mddr_settings.periodic_zq_cal_en?STR_ON:STR_OFF
        ,init_parms_ptr->mddr_settings.prop_delay);

    monaco_log(HIGH, "|CLK:%s  SSC:%s  DQS_DELAY:%d\n"
        ,(init_parms_ptr->mddr_settings.clk_type==CLK_INTERNAL_CLKGEN)?"CLKGEN":
        ((init_parms_ptr->mddr_settings.clk_type==CLK_EXTERNAL_AGERA)?"AGERA":"?")
        ,init_parms_ptr->mddr_settings.clkgen_ssc_en?STR_ON:STR_OFF
        ,init_parms_ptr->mddr_settings.extra_dqs_toggle);

    monaco_log(CRITICAL, "|AUTOREFRESH:%s  ADJ_DIMM0:%s  ADJ_DIMM1:%s\n"
        ,(init_parms_ptr->mddr_settings.rfc_mode==DDR_REFRESH_1X)?"1X":
        ((init_parms_ptr->mddr_settings.rfc_mode==DDR_REFRESH_2X)?"2X":
        ((init_parms_ptr->mddr_settings.rfc_mode==DDR_REFRESH_4X)?"4X":"?"))
        ,(init_parms_ptr->mddr_settings.adj_ref_dimm0==DIMM_REFRESH_RATE_4x)?"4X":
        ((init_parms_ptr->mddr_settings.adj_ref_dimm0==DIMM_REFRESH_RATE_2x)?"2X":
        ((init_parms_ptr->mddr_settings.adj_ref_dimm0==DIMM_REFRESH_RATE_1x)?"1X":
        ((init_parms_ptr->mddr_settings.adj_ref_dimm0==DIMM_REFRESH_RATE_ONE_HALF)?"1/2X":
        ((init_parms_ptr->mddr_settings.adj_ref_dimm0==DIMM_REFRESH_RATE_ONE_QUARTER)?"1/4X":"?"))))
        ,(init_parms_ptr->mddr_settings.adj_ref_dimm1==DIMM_REFRESH_RATE_4x)?"4X":
        ((init_parms_ptr->mddr_settings.adj_ref_dimm1==DIMM_REFRESH_RATE_2x)?"2X":
        ((init_parms_ptr->mddr_settings.adj_ref_dimm1==DIMM_REFRESH_RATE_1x)?"1X":
        ((init_parms_ptr->mddr_settings.adj_ref_dimm1==DIMM_REFRESH_RATE_ONE_HALF)?"1/2X":
        ((init_parms_ptr->mddr_settings.adj_ref_dimm1==DIMM_REFRESH_RATE_ONE_QUARTER)?"1/4X":"?")))));

    monaco_log(CRITICAL, "|AUTOPRECH:%s  PAGE POLICY:%s  IDLE TIMER:0x%x\n"
        ,init_parms_ptr->mddr_settings.page_settings.enable_auto_pchg?STR_ON:STR_OFF
        ,(init_parms_ptr->mddr_settings.page_settings.page_policy==DDR_PAGE_POLICY_CLOSED)?"CLOSED":
         ((init_parms_ptr->mddr_settings.page_settings.page_policy==DDR_PAGE_POLICY_OPEN)?"OPEN":
         ((init_parms_ptr->mddr_settings.page_settings.page_policy==DDR_PAGE_POLICY_TIMER)?"TIMER":"?"))
        ,init_parms_ptr->mddr_settings.page_settings.page_idle_timer);

    monaco_log(CRITICAL, "|AUTO SELFREFRESH:%s\n"
        ,init_parms_ptr->mddr_settings.auto_self_refresh_en?STR_ON:STR_OFF);
    if(init_parms_ptr->mddr_settings.auto_self_refresh_en)
    {
        monaco_log(CRITICAL, "|  IDLE TIME:0x%x\n"
            ,init_parms_ptr->mddr_settings.sr_entry_idle_delay);
    }

    monaco_log(CRITICAL, "|AUTO POWER DOWN :%s\n"
        ,(init_parms_ptr->mddr_settings.auto_power_down_en?STR_ON:STR_OFF));
    if(init_parms_ptr->mddr_settings.auto_power_down_en)
    {
        monaco_log(CRITICAL, "|  IDLE TIME:0x%x\n"
            ,init_parms_ptr->mddr_settings.pd_entry_idle_delay);
    }

    monaco_log(CRITICAL, "|DFI LOW POWER MODE:%s\n"
        ,(init_parms_ptr->mddr_settings.dfi_lp_mode==DFI_LP_DISABLED)?"DISABLED":
        ((init_parms_ptr->mddr_settings.dfi_lp_mode==DFI_LP_SR_ENA)?"LP_SR":
        ((init_parms_ptr->mddr_settings.dfi_lp_mode==DFI_LP_SR_PD_ENA)?"LP_SRPD":
        ((init_parms_ptr->mddr_settings.dfi_lp_mode==DFI_LP_SR_ENA_LP2_ENA)?"LP_SR_LP2":
        ((init_parms_ptr->mddr_settings.dfi_lp_mode==DFI_LP_SR_PD_ENA_LP2_ENA)?"LP_SRPD_LP2":"?")))));
    if(init_parms_ptr->mddr_settings.dfi_lp_mode)
    {
        monaco_log(CRITICAL, "|  IDLE TIME:0x%x\n"
            ,init_parms_ptr->mddr_settings.dfi_lp2_entry_idle_delay);
    }

    monaco_log(CRITICAL, "|TEMP EVENT      :%s\n"
        ,init_parms_ptr->mddr_settings.tcrit_event_en?STR_ON:STR_OFF);
    if(init_parms_ptr->mddr_settings.tcrit_event_en)
    {
        monaco_log(CRITICAL, "|  CRIT TEMP: %dC\n"
            ,init_parms_ptr->mddr_settings.tcrit_threshhold);
    }

    monaco_log(CRITICAL, "|ECC             :%s\n"
        ,(init_parms_ptr->mddr_settings.disable_ecc?STR_OFF:STR_ON));
    if(!init_parms_ptr->mddr_settings.disable_ecc)
    {
        monaco_log(CRITICAL, "|  RDWR_MODE:0x%x  SCRUB:%s\n"
            ,init_parms_ptr->mddr_settings.ecc_wrrd_mode
            ,init_parms_ptr->mddr_settings.disable_patrol_scrub?STR_OFF:STR_ON);
    }

    monaco_log(CRITICAL, "|COMPRESSION     : %s  QUAD_DET: %s\n"
        ,(init_parms_ptr->mddr_settings.comp_settings.comp_mode==DDR_COMP_ADAPTIVE)?"ADAPTIVE":
         ((init_parms_ptr->mddr_settings.comp_settings.comp_mode==DDR_COMP_STATIC)?"STATIC":
         ((init_parms_ptr->mddr_settings.comp_settings.comp_mode==DDR_COMP_DISABLED)?"DISABLED":"?"))
        ,(init_parms_ptr->mddr_settings.rs_quad_det_en>0?STR_ON:STR_OFF));
    if(init_parms_ptr->mddr_settings.comp_settings.comp_mode != DDR_COMP_DISABLED)
    {
        monaco_log(CRITICAL, "|  THRE HI: %d  LO: %d  RDWND: %d\n"
            ,init_parms_ptr->mddr_settings.comp_settings.cde_comprd_hi_threshold
            ,init_parms_ptr->mddr_settings.comp_settings.cde_comprd_lo_threshold
            ,init_parms_ptr->mddr_settings.comp_settings.cde_rd_window_size);

        monaco_log(CRITICAL, "|  HIST SIZE: %d  THRE: %d\n"
            ,init_parms_ptr->mddr_settings.comp_settings.cde_rd_hist_size
            ,init_parms_ptr->mddr_settings.comp_settings.cde_rd_hist_threshold);

        monaco_log(HIGH, "|  WDB: %s  QDB: %s\n"
            ,(init_parms_ptr->mddr_settings.comp_settings.cde_wdb_rd_mode==RD_COMPRESSED)?"COMPRSS":
            ((init_parms_ptr->mddr_settings.comp_settings.cde_wdb_rd_mode==RD_GLBL_ADAPTIVE_TRK_QSB)?"ADPQSB":
            ((init_parms_ptr->mddr_settings.comp_settings.cde_wdb_rd_mode==RD_GLBL_ADAPTIVE_TRK_WDB)?"ADPWDB":
            ((init_parms_ptr->mddr_settings.comp_settings.cde_wdb_rd_mode==RD_GLBL_ADAPTIVE_TRK_QSB_WDB)?"ADPQSBWDB":"?")))
            ,(init_parms_ptr->mddr_settings.comp_settings.cde_qsb_rd_mode==RD_COMPRESSED)?"COMPRSS":
            ((init_parms_ptr->mddr_settings.comp_settings.cde_qsb_rd_mode==RD_ADAPTIVE_PER_MASTER)?"ADPPER":
            ((init_parms_ptr->mddr_settings.comp_settings.cde_qsb_rd_mode==RD_ADAPTIVE_PER_MASTER_UNCOMP)?"ADPPERUNC":
            ((init_parms_ptr->mddr_settings.comp_settings.cde_qsb_rd_mode==RD_ADAPTIVE_PER_MASTER_COMP)?"ADPPERCOM":
            ((init_parms_ptr->mddr_settings.comp_settings.cde_qsb_rd_mode==RD_GLBL_ADAPTIVE_TRK_QSB)?"ADPQSB":
            ((init_parms_ptr->mddr_settings.comp_settings.cde_qsb_rd_mode==RD_GLBL_ADAPTIVE_TRK_WDB)?"ADPWDB":
            ((init_parms_ptr->mddr_settings.comp_settings.cde_qsb_rd_mode==RD_GLBL_ADAPTIVE_TRK_QSB_WDB)?"ADPQSBWDB":"?")))))));
    }
    monaco_log(HIGH, "+---------------------------------------------------+\n");
    monaco_log(CRITICAL, "|L3 AFFI: %s  HASH: %s\n"
        ,init_parms_ptr->l3_settings.affinity?STR_ON:STR_OFF
        ,init_parms_ptr->l3_settings.addr_hash_en?STR_ON:STR_OFF);
    monaco_log(HIGH, "|LL QUERY: %s  BREAKER: %s  SNOOP FLT: %s\n"
        ,init_parms_ptr->l3_settings.LL_query_en?STR_ON:STR_OFF
        ,init_parms_ptr->l3_settings.LL_breaker_en?STR_ON:STR_OFF
        ,init_parms_ptr->l3_settings.snoop_fltr_en?STR_ON:STR_OFF);
    monaco_log(CRITICAL, "|RPLCPOLICY: %s  CACHE MON: %s\n"
        ,(init_parms_ptr->l3_settings.rplcmnt_policy==LRU)?"LRU":
        ((init_parms_ptr->l3_settings.rplcmnt_policy==RANDOM)?"RNDOM":"?")
        ,init_parms_ptr->l3_settings.cache_cap_mon_en?STR_ON:STR_OFF);
    monaco_log(CRITICAL, "|AUTOCLKGATING: %s\n"
        ,init_parms_ptr->l3_settings.auto_gate_clk_en?STR_ON:STR_OFF);
    if(init_parms_ptr->l3_settings.auto_gate_clk_en)
    {
        monaco_log(CRITICAL, "|  CYCLE:0x%x\n"
            ,init_parms_ptr->l3_settings.auto_gate_idle_clk_cyc_cnt);
    }

    monaco_log(HIGH, "+---------------------------------------------------+\n");
    monaco_log(HIGH, "|RS SBRCE        : %s\n"
        ,(init_parms_ptr->rs_settings.rs_sbrce_ena?STR_ON:STR_OFF));
    if(init_parms_ptr->rs_settings.rs_sbrce_ena)
    {
        monaco_log(HIGH, "|  SBRLVL: LVL_%d  SBRMSK: 0x%x\n"
            ,init_parms_ptr->rs_settings.rs_sbrlvl
            ,init_parms_ptr->rs_settings.rs_sbrmsk);
    }
    monaco_log(HIGH, "|RS DLBU         : %s\n"
        ,(init_parms_ptr->rs_settings.rs_dlbu_ena?STR_ON:STR_OFF));
    monaco_log(HIGH, "|RS EROUTE       : %s\n"
        ,(init_parms_ptr->rs_settings.rs_eroute_ena?STR_ON:STR_OFF));
    monaco_log(HIGH, "|RS LFSR         : %s\n"
        ,init_parms_ptr->rs_settings.rs_lfsr_ena?STR_ON:STR_OFF);
    monaco_log(CRITICAL, "|RS BUM MON      : %s\n"
        ,init_parms_ptr->rs_settings.rs_bum_ena?STR_ON:STR_OFF);
    if(init_parms_ptr->rs_settings.rs_bum_ena)
    {
        monaco_log(HIGH, "|  MAXINDX: %d\n"
            ,init_parms_ptr->rs_settings.rs_perfndx_max);
    }

    monaco_log(CRITICAL, "|CLKONREQ        : %s\n"
        ,(init_parms_ptr->rs_settings.rs_clkon_req_ena?STR_ON:STR_OFF));
    if(init_parms_ptr->rs_settings.rs_clkon_req_ena)
    {
        monaco_log(CRITICAL, "|  DELAY: 0x%x  HYST: 0x%x\n"
            ,init_parms_ptr->rs_settings.rs_clkon_delay
            ,init_parms_ptr->rs_settings.rs_clkon_hysteresis);
    }

    monaco_log(CRITICAL, "+===================================================+");
}

/* ============================================================================
**  Function : ddr_get_si
** ===========================================================================*/
static bool ddr_si_table_loaded = false;
extern void sbl_read_ddrsi_table(char *note_name, unsigned long *ddrsi_base);
void ddr_get_si(mddr_si_selector_t *selector_ptr, mddr_si_chan_t *si_data_ptr)
{

    int platform_info;
    DDRSIDataHdr_t SIHdr;
    char Platform_name[4];
    char table_name[16];
    uint8_t SiliconMajorVerion;
    uint8_t SiliconMinorVerion;
    uint32_t DimmDataSize;
    uint32_t ChannelDataSize;
    uint32_t ChannelSize;
    uint32_t FirstDimmSize;
    int eResult;
    int err_status = 0x0;
    int i;
    DIEINFO_PROPS DieInfo;

    // the table need to load once, each channels will use same table
    if( !ddr_si_table_loaded)
    {
        /*  Build up DDR SI Table name    */
        /*=====================*/
        memset(table_name,0,16);

        // Read platform information
#ifdef HARVEST
        platform_info = DALPLATFORMINFO_TYPE_CRB;
#endif

        //Platform name
        if(platform_info == DALPLATFORMINFO_TYPE_RUMI)
        {
            strlcpy(&Platform_name[0],"RUM",4);
        }
        else if(platform_info == DALPLATFORMINFO_TYPE_SDP)
        {
            // Qualcomm reference platform(SDP)
            strlcpy(&Platform_name[0],"SDP",4);
        }
        else if(platform_info == DALPLATFORMINFO_TYPE_CRB)
        {
            // Qualcomm reference platform(CRB)
            strlcpy(&Platform_name[0],"CRB",4);
        }
        else
        {
            // Custom devices
            strlcpy(&Platform_name[0],"CUS",4);
        }
        strlcpy(&table_name[0],&Platform_name[0],4);

        //silicon version name
        get_socket_info(&DieInfo, 0);
        SiliconMajorVerion=DieInfo.MajorVersion;
        SiliconMinorVerion=DieInfo.MinorVersion;

        // For v1.x, if minor version higher than 1 detected, use settings for v1.1
        if(SiliconMajorVerion == 1)
        {
            if(SiliconMinorVerion > 1)
            {
                SiliconMinorVerion = 1;
            }
        }
        // For v2.x, if minor version higher than 0 detected, use settings for v2.0
        else if(SiliconMajorVerion == 2)
        {
            if(SiliconMinorVerion > 0)
            {
                SiliconMinorVerion = 0;
            }
        }

        // find the compatible tables
        for(i=0;i<sizeof(ddrsi_compatible_table)/sizeof(SoCCompatible_t);i++)
        {
            if(ddrsi_compatible_table[i].readVer[0]==SiliconMajorVerion &&
                ddrsi_compatible_table[i].readVer[1]==SiliconMinorVerion)
            {
                SiliconMajorVerion = ddrsi_compatible_table[i].mapVer[0];
                SiliconMinorVerion = ddrsi_compatible_table[i].mapVer[1];
            }
        }

        snprintf((void*)&table_name[3], 4,
            "%u%u",
            SiliconMajorVerion, SiliconMinorVerion);

        /*  Check if SI table selector is valid    */
        /*========================*/
        // 2DPC/1DPC
        if(selector_ptr->num_dimm_slots ==1)
            strlcat(&table_name[5], "SN",7);
        else if(selector_ptr->num_dimm_slots ==2)
            strlcat(&table_name[5], "DU",7);
        else
            err_status |= 0x1 <<1;

        // Frequency
        if(selector_ptr->mem_freq_mhz <800)
            err_status |= 0x1 <<2;
        else if(selector_ptr->mem_freq_mhz <933)
            strlcat(&table_name[7], "F08",10);
        else if(selector_ptr->mem_freq_mhz <1066)
            strlcat(&table_name[7], "F09",10);
        else if(selector_ptr->mem_freq_mhz <1200)
            strlcat(&table_name[7], "F10",10);
        else if(selector_ptr->mem_freq_mhz <1333)
            strlcat(&table_name[7], "F12",10);
        else if(selector_ptr->mem_freq_mhz <1466)
            strlcat(&table_name[7], "F13",10);
        else if(selector_ptr->mem_freq_mhz <1600)
            strlcat(&table_name[7], "F14",10);
        else if(selector_ptr->mem_freq_mhz <1733)
            strlcat(&table_name[7], "F16",10);
        else
            err_status |= 0x1 <<2;

        // number of Dimm populated
        if(selector_ptr->num_dimm_slots_pop ==1)
        {
            strlcat(&table_name[10], "1D",12);
            //number of the rank per channel in 1DPC or 1dimm in 2DPC
            if(selector_ptr->num_ranks_slot[0] ==1)
                strlcat(&table_name[12], "1R",14);
            else if(selector_ptr->num_ranks_slot[0] ==2)
                strlcat(&table_name[12], "2R",14);
            else if(selector_ptr->num_ranks_slot[0] ==4)
                strlcat(&table_name[12], "4R",14);
            else if(selector_ptr->num_ranks_slot[0] ==0 && selector_ptr->num_ranks_slot[1] >0)
                // slot1 only populated, invalid dimm configuration
                err_status |= 0x1 <<6;
            else
                // invalid rank of dimm is populated
                err_status |= 0x1 <<4;
        }
        else if(selector_ptr->num_dimm_slots_pop ==2)
        {
            strlcat(&table_name[10], "2D",12);
            //number of the rank per channel in 2DPC system
            if(selector_ptr->num_ranks_slot[0] ==1 && selector_ptr->num_ranks_slot[1] ==1)
                strlcat(&table_name[12], "11R",15);
            else if(selector_ptr->num_ranks_slot[0] ==2 &&selector_ptr->num_ranks_slot[1] ==2)
                strlcat(&table_name[12], "22R",15);
            else if(selector_ptr->num_ranks_slot[0] ==1 && selector_ptr->num_ranks_slot[1] ==2)
                strlcat(&table_name[12], "21R",15);
            else if(selector_ptr->num_ranks_slot[0] ==2 && selector_ptr->num_ranks_slot[1] ==1)
                strlcat(&table_name[12], "12R",15);
            else
                // invalid rank of dimm is populated
                err_status |= 0x1 <<5;
        }
        else
        {
            err_status |= 0x1 <<3;
        }

        //   ********************************************
        //   err_status stands for not supported DDR configuration
        //   *DDR Driver calls invalid or not existing combination
        //   bit 0: Unsupported platform {SDP|RUM|CBR|CUSTOM}
        //   bit 1: Unsupported DPC configuration {2DPC/1DPC}
        //   bit 2: Unsupported DDR Frequency {800/933/1066/1200/1333/1466}
        //   bit 3: Unsupported number of DIMM per channel {1/2}
        //   bit 4: Unsupported rank combination in 1DPC
        //   bit 5: Unsupported rank combination in 2DPC
        //   bit 6: no DDR dimm found

        if(err_status != 0 && strncmp(SIHdr.platform, "SI",strlen(SIHdr.platform))==0)
        {
            monaco_log(CRITICAL,"********  DDR Memory Configuration Error Detected  *********\n");
            if ((err_status >> 1) & 0x1)
                monaco_log(CRITICAL,"*  Unsupported DPC configuration {2DPC/1DPC}: %d\n", selector_ptr->num_dimm_slots);
            if ((err_status >> 2) & 0x1)
                monaco_log(CRITICAL,"*  Unsupported DDR Frequency {800/933/1066/1200/1333}: %d\n", selector_ptr->mem_freq_mhz);
            if ((err_status >> 3) & 0x1)
            {
                if(selector_ptr->num_dimm_slots_pop ==0)
                    monaco_log(CRITICAL,"*  No DDR found\n");
                else
                    monaco_log(CRITICAL,"*  Unsupported number of DIMM per channel {1/2}: %d\n", selector_ptr->num_dimm_slots_pop);
            }
            if ((err_status >> 5) & 0x1)
            {
                monaco_log(CRITICAL,"*  Unsupported rank combination (2DPC): ranks(0)=%d\n", selector_ptr->num_ranks_slot[0]);
                monaco_log(CRITICAL,"*                                       ranks(1)=%d\n", selector_ptr->num_ranks_slot[1]);
            }
            if ((err_status >> 4) & 0x1)
            {
                monaco_log(CRITICAL,"*  Unsupported rank combination (1DPC): ranks=%d\n", selector_ptr->num_ranks_slot[0]);
            }
            if ((err_status >> 6) & 0x1)
                monaco_log(CRITICAL,"*  Invalid DDR location, please put DDR memory in slot 0\n");
            monaco_log(CRITICAL,"************************************************************\n");
        }


        if(ddr_margining_result ==0)
        {
            // Get the pointer of Table preloaded subnote in memory
            sbl_read_ddrsi_table(table_name, &ddrsi_base);
        }

        ddr_si_table_loaded = true;

        //Load Header from the table
        memcpy((void *)&SIHdr,(void *)ddrsi_base, sizeof(DDRSIDataHdr_t));

        /* If SI Table comes from Margining mode,
        *  All header information is not informative
        *  So skip header validation
        */

        //Check if header information is matched with requester
        if(platform_info == DALPLATFORMINFO_TYPE_RUMI)
        {
            // RUMI is emulation platform
            if(SIHdr.DPCconfig != selector_ptr->num_dimm_slots ||
               SIHdr.DIMMconfig != selector_ptr->num_dimm_slots_pop)
            {
                err_status |= 0x1 <<9;
            }
        }
        else
        {
            // Check if system information matched
            if(SIHdr.DPCconfig != selector_ptr->num_dimm_slots ||
               SIHdr.DIMMconfig != selector_ptr->num_dimm_slots_pop)
            {
                err_status |= 0x1 <<9;
            }

            // Check if rank configuration matched
            if(SIHdr.DIMMconfig == 2)
            {
                if(SIHdr.RANKconfig[0]!=selector_ptr->num_ranks_slot[0]
                    || SIHdr.RANKconfig[1]!=selector_ptr->num_ranks_slot[1])
                {
                    err_status |= 0x1 <<10;
                }
            }

            if(SIHdr.DIMMconfig == 1
                && (SIHdr.RANKconfig[0] != selector_ptr->num_ranks_slot[0]))
            {
                err_status |= 0x1 <<10;
            }
        }
        //   ********************************************
        //   err_status stands for not supported DDR configuration
        //   *SI data corruption
        //   bit 8: System information in Header of table not matched with requested.
        //   bit 9: DDR board configuration in Header of table not matched with requested.
        //   bit 10: Rank information in Header of table not matched with requested one.

        if(err_status != 0 && strncmp(SIHdr.platform, "SI",strlen(SIHdr.platform))==0)
        {
            monaco_log(CRITICAL,"****************  SI data Errors Detected   ****************\n");
            monaco_log(CRITICAL,"* DDRSI table header does not match DDR configuration.\n");
            monaco_log(CRITICAL,"*               Header          Platform\n");

            if ((err_status >> 9) & 0x1)
            {
                monaco_log(CRITICAL,"*  Board type:  %dDPC            %dDPC\n", SIHdr.DPCconfig, selector_ptr->num_dimm_slots);
                monaco_log(CRITICAL,"*  Populated :  %dDIMM(s)        %dDIMM(s)\n", SIHdr.DIMMconfig, selector_ptr->num_dimm_slots_pop);
            }
            if ((err_status >> 10) & 0x1)
            {
                monaco_log(CRITICAL,"*  Ranks:       slot[0]=%d       slot[0]=%d\n", SIHdr.RANKconfig[0], selector_ptr->num_ranks_slot[0]);
                if (SIHdr.DIMMconfig == 2)
                {
                    monaco_log(CRITICAL,"*  Ranks:       slot[1]=%d       slot[1]=%d\n", SIHdr.RANKconfig[1], selector_ptr->num_ranks_slot[1]);
                }
            }

            monaco_log(CRITICAL,"************************************************************\n");

        }
    }

    // Offset of Source binary table
    DimmDataSize = sizeof(mddr_si_dimm_t)-sizeof(mddr_si_rank_t)* DDR_MAX_RANKS_PER_SLOT;
    ChannelDataSize = sizeof(mddr_si_chan_t)-sizeof(mddr_si_dimm_t)*DDR_MAX_NUM_SLOTS_PER_CHAN;
    ChannelSize = ChannelDataSize + DimmDataSize * selector_ptr->num_dimm_slots_pop
        + sizeof(mddr_si_rank_t)* selector_ptr->num_ranks_slot[0];

    // Offset of Source binary table
    FirstDimmSize= ChannelDataSize + DimmDataSize + sizeof(mddr_si_rank_t)* (selector_ptr->num_ranks_slot[0]);

    if( selector_ptr->num_dimm_slots_pop ==2)
    {
        ChannelSize += sizeof(mddr_si_rank_t)* selector_ptr->num_ranks_slot[1];
    }
    // Copy channel data and DIMM0 data
    memcpy(si_data_ptr
        ,(void *)(ddrsi_base+sizeof(DDRSIDataHdr_t)+(ChannelSize*selector_ptr->ddr_chan))
        , FirstDimmSize);
    if( selector_ptr->num_dimm_slots_pop ==2)
    {
        // Copy DIMM1 data
        memcpy((void *)&si_data_ptr->dimm_si[1]
            ,(void *)(ddrsi_base+sizeof(DDRSIDataHdr_t)+(ChannelSize*selector_ptr->ddr_chan)+FirstDimmSize)
            , DimmDataSize + sizeof(mddr_si_rank_t)* (selector_ptr->num_ranks_slot[1]));
    }
}

/* ============================================================================
**  Function : ddr_store_margining_result
** ===========================================================================*/
extern void sbl_store_ddr_margining_result(void);
void ddr_store_margining_result(void)
{
    sbl_store_ddr_margining_result();
}

/* ============================================================================
**  Function : ddr_is_ddr_margining_done
** ===========================================================================*/
extern void sbl_check_margining_enable(unsigned long *ddrsi_base, void *margin_config_data, unsigned long *ddr_margining_result);
void ddr_check_margining_enable(unsigned long *ddrsi_base, void *margin_config_data, unsigned long *ddr_margining_result)
{
    sbl_check_margining_enable(ddrsi_base, margin_config_data, ddr_margining_result);
}

/* ============================================================================
**  Function : monaco_spd_cached_init
** ===========================================================================*/
void monaco_spd_cached_init(dimm_slot_smbus_info_t *smbus_info_p, uint64_t spd_base)
{
    uint8_t ddr_chan;
    uint8_t dimm_slot;
    uint8_t spd_dev_info;
    int16_t bytes_total;
    dimm_slot_smbus_info_t *smbus_ptr;
    int ret;
    SPD_CONFIG_ENTRY_HEADER hdr;
    SPD_CONFIG_TABLE_HEADER thdr;
    uint32_t spd_table_idx=0;
    void *spd_read_ptr=NULL;

    monaco_log(CRITICAL, " Reading SPD............\n" );

    memset((void *)&thdr, 0, sizeof(SPD_CONFIG_TABLE_HEADER));
    memset ((uint8_t *)spd_offset, 0xff, sizeof(uint16_t) * DDR_MAX_NUM_CHANS * DDR_MAX_NUM_SLOTS_PER_CHAN);

    spd_cached_base = (void *)spd_base;
    if(spd_cached_base == NULL)
        return; // If base address is NULL, let SDP read API reads directly from EEPROM

    // Go through each DIMM SPD and get the associated SPD information in physical order.
    for(ddr_chan = 0; ddr_chan < DDR_MAX_NUM_CHANS; ++ddr_chan)
    {
        for(dimm_slot = 0; dimm_slot < DDR_MAX_NUM_SLOTS_PER_CHAN; ++dimm_slot)
        {
            memset((void *)&hdr, 0, sizeof(SPD_CONFIG_ENTRY_HEADER));
            // Need to get number of bytes total in the serial EEPROM for the correct load size.
            smbus_ptr = (dimm_slot_smbus_info_t *)(smbus_info_p + ddr_physical_to_logical_channel(ddr_chan)*DDR_MAX_NUM_SLOTS_PER_CHAN + dimm_slot);
            ret = xbl_smbus_read_generic(smbus_ptr->smbus_id
                , smbus_ptr->spd_eeprom_bus_addr>>1
                , 0
                , &spd_dev_info
                , 1);
            if(ret == 0)
            {
                bytes_total = ((spd_dev_info >> SPD_BYTES_TOTAL___S) & SPD_BYTES_TOTAL___M)* SPD_BLOCK_SIZE;
                if((bytes_total > 0) && (bytes_total <= SPD_MAX_SERIAL_EEPROM_SIZE))
                {
                    // Read the block of SPD data into memory for the given channel/slot.
                    spd_read_ptr = spd_cached_base + sizeof(SPD_CONFIG_TABLE_HEADER)
                        + spd_table_idx*(SPD_MAX_SERIAL_EEPROM_SIZE+sizeof(SPD_CONFIG_ENTRY_HEADER));
                    ret=xbl_smbus_read_generic(smbus_ptr->smbus_id
                        , smbus_ptr->spd_eeprom_bus_addr>>1
                        , 0
                        , spd_read_ptr + sizeof(SPD_CONFIG_ENTRY_HEADER)
                        , bytes_total);
                    if(ret == 0)
                    {
                        // Fill in DiMM header
                        hdr.Version = SPD_CONFIG_ENTRY_VERSION;
                        hdr.HeaderSize = sizeof(hdr);
                        hdr.TotalSize = sizeof(hdr) + bytes_total;
                        hdr.Channel = ddr_chan;
                        hdr.Slot = dimm_slot;
                        spd_offset[ddr_chan][dimm_slot]= spd_table_idx*(SPD_MAX_SERIAL_EEPROM_SIZE+sizeof(SPD_CONFIG_ENTRY_HEADER));
                        memcpy(spd_read_ptr, &hdr, sizeof(SPD_CONFIG_ENTRY_HEADER));
                        spd_table_idx++;
                    }
                }
            }
        }
    }

    //Fill in Table header
    thdr.Version = SPD_CONFIG_TABLE_VERSION;
    thdr.HeaderSize = sizeof(thdr);
    thdr.TotalSize =  spd_table_idx * (SPD_MAX_SERIAL_EEPROM_SIZE+sizeof(SPD_CONFIG_ENTRY_HEADER));
    thdr.NumDIMMs = spd_table_idx;
    memcpy(spd_cached_base, &thdr, sizeof(SPD_CONFIG_TABLE_HEADER));
}
