//----------------------------------------------------------------------------
//   The confidential and proprietary information contained in this file may
//   only be used by a person authorised under and to the extent permitted
//   by a subsisting licensing agreement from ARM Limited or its affiliates.
//
//          (C) COPYRIGHT [2020] ARM Limited or its affiliates.
//              ALL RIGHTS RESERVED
//
//   This entire notice must be reproduced on all copies of this file
//   and copies of this file may only be made by a person if such person is
//   permitted to do so under the terms of a subsisting license agreement
//   from ARM Limited or its affiliates.
//----------------------------------------------------------------------------

/*
    Auto White Balance module:
        1. Plankian curve based
        2. Mesh lookup table based
        3. NBP decision tables

    Controls:
        AWB_SMOOTH_FILTER     - Enable smooth filter (fifo depth is FIFO_DEPTH)
        AWB_PRINT_DEBUG        - Enable test mode (with tracing debug information)
        AWB_TEST_DATA       - Runs test data through the system
        AWB_SIM_OLD_MESH    - Change probablities to simulation old awb mesh algorithm

    Default configuration:
        AWB_SMOOTH_FILTER - disable
        AWB_PRINT_DEBUG      - disable
        AWB_TEST_DATA     - disable
        AWB_SIM_OLD_MESH  - disable

    Sensor-depended DATA SECTION:    (TBD: DATA SECTION should be generated by the calibration tool)
        1. light_src
        2. rg_pos
        3. bg_pos
        4. rgbg_weight
        5. rgbg_ls_weight
        6. color_temp_mesh
        7. p_rg_low
        8. p_rg_high
        9. p_lux_low
        10. p_lux_high
        11. color_temp
        12. ct_rg_pos_calc
        13. ct_bg_pos_calc

    Structure of the module:
        1. Controls
        2. DATA SECTION (see $SENSOR_mesh_lookup.h)
        3. Routines
        4. AWB functions (calling order:  awb.scxml)


*/

#include "3a/awb/awb_acamera_core.h"
#include "3a/acamera_math.h"
#include "3a/3a_config.h"


//=============Controls===========================================================
#define AWB_SMOOTH_FILTER
#define AWB_BG_MAX_GAIN /* Clip maxium gains for bg according to gain */

//================================================================================

#ifdef AWB_PRINT_DEBUG
#endif

//================================================================================

typedef struct {
    uint8_t p_high;
    uint8_t p_low;
    uint8_t internal_inited;

    uint32_t rg_avg;
    uint32_t gb_avg;
    uint32_t stable_avg_RG;
    uint32_t stable_avg_BG;
    uint32_t avg_GR;
    uint32_t avg_GB;
    uint16_t rg_coef;
    uint16_t bg_coef;

    int32_t max_temp;
    int32_t min_temp;
    uint16_t max_temp_rg;
    uint16_t max_temp_bg;
    uint16_t min_temp_rg;
    uint16_t min_temp_bg;

    int32_t temperature_detected;
    uint8_t light_source_candidate;

    int32_t awb_warming_A[3];
    int32_t awb_warming_D75[3];
    int32_t awb_warming_D50[3];
    int32_t awb_warming[3];

    uint8_t mvalid[MAX_AWB_ZONES];
    uint8_t cwfzones[MAX_AWB_ZONES];
    uint8_t npcHigh[MAX_AWB_ZONES];
    uint8_t npcLow[MAX_AWB_ZONES];
    uint8_t sky_zones[MAX_AWB_ZONES];
    uint16_t rg_valid[MAX_AWB_ZONES];
    uint16_t bg_valid[MAX_AWB_ZONES];
    uint32_t weight_[MAX_AWB_ZONES];

    uint8_t awb_converged;
} awb_acamera_core_obj_t;

//===========Routines=============================================================


/*------ LUTS fetchers -----------------*/
static uint16_t luts_fetch_u16( const uint32_t val, const uint32_t min, const uint32_t max, const uint32_t step,
                                const uint16_t *const data, const size_t len )
{
    uint16_t res = 0u;

    if ( ( data == NULL ) || ( len == 0u ) || ( step == 0u ) ) {
        // We have violated our assumptions, return val as a fallback.
        uint32_t temp_u32 = val;
        temp_u32 = acamera_min_u32( temp_u32, 0xFFFFu ); // clamp down to u16 max;
        res = (uint16_t)temp_u32;
    } else {
        size_t index;
        if ( val < min ) {
            index = 0u;
        } else if ( val > max ) {
            index = len - 1u;
        } else {
            // We know val > min here, index cannot underflow here.
            const uint32_t temp_u32 = ( val - min ) / step;
            index = ( size_t )( temp_u32 ); // Division by zero is checked

            // Check our index is not out of bound
            index = ( index >= len ) ? ( len - 1u ) : index;
        }

        res = data[index];
    }

    return res;
}

static uint16_t luts_rg_low( const uint32_t val )
{
    const uint16_t rglow_lut[] = {
        3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 6, 6,
        6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 11, 11,
        11, 12, 12, 13, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 20, 20, 21,
        21, 22, 23, 23, 24, 25, 26, 26, 27, 28, 29, 30, 31, 31, 32, 33, 34, 35, 36, 37,
        38, 40, 41, 42, 43, 44, 45, 47, 48, 49, 51, 52, 53, 55, 56, 58, 60, 61, 63, 64,
        66, 68, 70, 72, 73, 75, 77, 79, 81, 83, 86, 88, 90, 92, 95, 97, 99, 102, 104, 107,
        110, 112, 115, 118, 121, 123, 126, 129, 133, 136, 139, 142, 145, 149, 152, 156, 159, 163, 167, 170,
        174, 178, 182, 186, 190, 194, 199, 203, 207, 212, 216, 221, 226, 231, 235, 240, 245, 250, 253u};
    const size_t len = sizeof( rglow_lut ) / sizeof( rglow_lut[0] );
    return luts_fetch_u16( val, 168, 326, 1, rglow_lut, len );
}

static const uint16_t rghigh_lut[] = {
    247, 242, 237, 233, 228, 223, 219, 215, 210, 206, 202, 198, 193, 189, 186, 182, 178, 174, 170, 167, 163, 160, 156,
    153, 150, 147, 143, 140, 137, 134, 131, 128, 125, 123, 120, 117, 114, 112, 109, 107, 104, 102, 100, 97, 95, 93,
    91, 89, 86, 84, 82, 80, 79, 77, 75, 73, 71, 69, 68, 66, 64, 63, 61, 60, 58, 57, 55, 54, 53,
    51, 50, 49, 48, 46, 45, 44, 43, 42, 41, 40, 38, 37, 36, 36, 35, 34, 33, 32, 31, 30, 29, 29,
    28, 27, 26, 26, 25, 24, 23, 23, 22, 22, 21, 20, 20, 19, 19, 18, 18, 17, 17, 16, 16, 15, 15,
    14, 14, 14, 13, 13, 12, 12, 12, 11, 11, 11, 10, 10, 10, 9, 9, 9, 9, 8, 8, 8, 8, 7,
    7, 7, 7, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4u};

static uint16_t luts_rg_high( const uint32_t val )
{
    const size_t len = sizeof( rghigh_lut ) / sizeof( rghigh_lut[0] );
    return luts_fetch_u16( val, 252, 419, 1, rghigh_lut, len );
}

static uint16_t luts_lux_low( const uint32_t val )
{
    const uint16_t luxlow_lut[] = {253, 251, 248, 243, 237, 229, 219, 207, 193, 179, 166, 154, 146, 141, 141, 146, 154,
                                   166, 179, 193, 207, 219, 229, 237, 243, 248, 251, 253, 253, 253, 253, 253, 253, 253,
                                   253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 251, 242, 233, 224, 215, 207, 199,
                                   191, 183, 175, 168, 161, 154, 147, 140, 134, 128, 122, 116, 110, 105, 100, 95, 90,
                                   85, 81, 76, 72, 68, 65, 61, 57, 54, 51, 48, 45, 43, 40, 37, 35, 33,
                                   31, 29, 27, 25, 24, 22, 21, 19, 18, 17, 15, 14, 13, 12, 11, 11, 10,
                                   9, 8, 8, 7, 7, 6, 6, 5, 5, 4, 4, 4, 3, 3, 3u};
    const size_t len = sizeof( luxlow_lut ) / sizeof( luxlow_lut[0] );
    return luts_fetch_u16( val, 88, 1483, 12, luxlow_lut, len );
}

static uint16_t luts_lux_high( const uint32_t val )
{
    const uint16_t luxhigh_lut[] = {
        12, 12, 13, 14, 15, 16, 19, 24, 31, 41, 55, 72, 91, 110, 125, 134, 135, 128, 115, 99, 81,
        65, 52, 42, 36, 33, 31, 31, 31, 32, 33, 34, 35, 36, 37, 39, 40, 41, 42, 44, 45, 46,
        48, 49, 51, 53, 54, 56, 58, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 80, 82, 84, 87,
        89, 92, 94, 97, 100, 103, 106, 108, 111, 115, 118, 121, 124, 128, 131, 135, 138, 142, 146, 150, 154,
        158, 162, 166, 171, 175, 179, 184, 189, 194, 198, 203, 209, 214, 219, 225, 230, 236, 241, 247, 253};
    const size_t len = sizeof( luxhigh_lut ) / sizeof( luxhigh_lut[0] );
    return luts_fetch_u16( val, 1, 1650, 16, luxhigh_lut, len );
}

/*------ LUTS fetchers END -------------*/

typedef struct {
    uint16_t x;
    uint16_t y;
    uint16_t weight;
} interp_2d_point_t;

/*------ Smooth filter system ----------*/
#ifdef AWB_SMOOTH_FILTER

static void fifo_push( awb_acamera_core_obj_t *p_awb_core_obj, const awb_calibration_data_t *p_cali_data, uint16_t rg,
                       uint16_t gb )
{
    uint8_t awb_avg_coeff = p_cali_data->cali_awb_avg_coef[0];

    if ( awb_avg_coeff == 0u ) // no average
    {
        p_awb_core_obj->rg_avg = rg;
        p_awb_core_obj->gb_avg = gb;
    } else if ( ( p_awb_core_obj->rg_avg == 0u ) && ( p_awb_core_obj->gb_avg == 0u ) ) // initialization
    {
        p_awb_core_obj->rg_avg = (uint32_t)rg * awb_avg_coeff;
        p_awb_core_obj->gb_avg = (uint32_t)gb * awb_avg_coeff;
    } else // normal IIR filtration
    {
        p_awb_core_obj->rg_avg += rg - ( p_awb_core_obj->rg_avg / awb_avg_coeff ); // division by zero is checked
        p_awb_core_obj->gb_avg += gb - ( p_awb_core_obj->gb_avg / awb_avg_coeff ); // division by zero is checked
    }
}

static interp_2d_point_t get_point( const awb_acamera_core_obj_t *p_awb_core_obj,
                                    const awb_calibration_data_t *p_cali_data )
{
    const uint16_t awb_avg_coeff = (uint16_t)p_cali_data->cali_awb_avg_coef[0];
    const uint16_t rg_avg = (uint16_t)p_awb_core_obj->rg_avg;
    const uint16_t gb_avg = (uint16_t)p_awb_core_obj->gb_avg;
    interp_2d_point_t point;
    if ( awb_avg_coeff != 0u ) {
        point.x = rg_avg / awb_avg_coeff; // division by zero is checked
        point.y = gb_avg / awb_avg_coeff; // division by zero is checked
    } else {
        point.x = rg_avg;
        point.y = gb_avg;
    }
    point.weight = 0u;
    return point;
}
#endif // AWB_SMOOTH_FILTER
/*----- Smooth filter system end ------*/

/*----- Mesh fetching functions -------*/

// Get nearest points from lookup table based on (rg&bg) position
static interp_2d_point_t init_interp_2d_point( const awb_calibration_data_t *p_cali_data, int32_t i, int32_t j,
                                               const uint16_t *p_table, const uint16_t *posx, const uint16_t *posy )
{
    uint32_t x_case, y_case;
    interp_2d_point_t p = {0};
    int32_t loc_i = i;
    int32_t loc_j = j;

    int32_t lut_length = (int32_t)p_cali_data->cali_rg_pos_len;

    x_case = ( uint32_t )( ( ( i <= lut_length ) && ( i >= 0 ) ) ? 1u : 0u ) + ( ( i > lut_length ) ? 2u : 0u );
    y_case = ( uint32_t )( ( ( j <= lut_length ) && ( j >= 0 ) ) ? 1u : 0u ) + ( ( j > lut_length ) ? 2u : 0u );

    switch ( x_case ) {
    case 0:
        p.x = posx[0] - 20u;
        loc_i = 0;
        break;
    case 2:
        p.x = posx[lut_length - 1] + 20u;
        loc_i = lut_length - 1;
        break;
    default:
        p.x = posx[i];
        break;
    };

    switch ( y_case ) {
    case 0:
        p.y = posy[0] - 20u;
        loc_j = 0;
        break;
    case 2:
        p.y = posy[lut_length - 1] + 20u;
        loc_j = lut_length - 1;
        break;
    default:
        p.y = posy[j];
        break;
    };

    p.weight = p_table[( loc_j * lut_length ) + loc_i];
    return p;
}


static uint32_t get_index( const awb_calibration_data_t *p_cali_data, const uint32_t v, const uint16_t *p_lut )
{
    const uint32_t lut_length = p_cali_data->cali_rg_pos_len;
    uint32_t indx = 0u;
    uint8_t found = 0u;
    uint32_t i;

    for ( i = 1; ( i < lut_length ); i++ ) {
        if ( v < p_lut[i] ) {
            indx = i - 1u;
            found = 1u;
            break;
        }
    }

    if ( found == 0u ) {
        if ( lut_length >= 2u ) {
            indx = lut_length - 2u;
        } else {
            indx = 0u;
        }
    }

    return indx;
}

// Get lookup value base on (rg&bg)
static uint16_t AWB_mesh( const awb_calibration_data_t *p_cali_data, uint16_t rg, uint16_t bg, const uint16_t *posx,
                          const uint16_t *posy, const uint16_t *p_table )
{
    uint16_t weight = 0, db1, db2;
    interp_2d_point_t p00, p01, p10, p11;
    int32_t x = (int32_t)get_index( p_cali_data, rg, posx );
    int32_t y = (int32_t)get_index( p_cali_data, bg, posy );

    p00 = init_interp_2d_point( p_cali_data, x, y, p_table, posx, posy );
    p01 = init_interp_2d_point( p_cali_data, x + 1, y, p_table, posx, posy );
    p10 = init_interp_2d_point( p_cali_data, x, y + 1, p_table, posx, posy );
    p11 = init_interp_2d_point( p_cali_data, x + 1, y + 1, p_table, posx, posy );

    uint16_t loc_rg = rg;
    uint16_t loc_bg = bg;

    // Limit rg/bg as per calibration table
    loc_rg = acamera_max_u16( loc_rg, p_cali_data->cali_rg_pos[0] );
    loc_rg = acamera_min_u16( loc_rg, p_cali_data->cali_rg_pos[p_cali_data->cali_rg_pos_len - 1u] );

    loc_bg = acamera_max_u16( loc_bg, p_cali_data->cali_bg_pos[0] );
    loc_bg = acamera_min_u16( loc_bg, p_cali_data->cali_bg_pos[p_cali_data->cali_bg_pos_len - 1u] );

    // NOTE: you changed these from rg/bg to irg/ibg
    db1 = (uint16_t)acamera_interpl_linear( (int32_t)loc_rg, (int32_t)p00.x, (int32_t)p00.weight, (int32_t)p01.x,
                                            (int32_t)p01.weight );
    db2 = (uint16_t)acamera_interpl_linear( (int32_t)loc_rg, (int32_t)p10.x, (int32_t)p10.weight, (int32_t)p11.x,
                                            (int32_t)p11.weight );

    weight =
        (uint16_t)acamera_interpl_linear( (int32_t)loc_bg, (int32_t)p00.y, (int32_t)db1, (int32_t)p10.y, (int32_t)db2 );

    return weight;
}


// A min/max/step look up table version of init_interp_2d_point_LUT
static interp_2d_point_t init_interp_2d_point_LUT( const awb_calibration_data_t *p_cali_data, uint16_t i, uint16_t j,
                                                   uint16_t minx, uint16_t maxx, uint16_t stepx, uint16_t miny,
                                                   uint16_t maxy, uint16_t stepy, const uint16_t *p_table )
{
    uint16_t loc_i = i;
    uint16_t loc_j = j;
    const uint16_t lut_length = (uint16_t)p_cali_data->cali_rg_pos_len;

    interp_2d_point_t p;

    p.x = 0;
    p.y = 0;
    p.weight = 0;

    if ( i >= lut_length ) {
        loc_i = lut_length - 1u;
        p.x = maxx + 20u;
    } else {
        p.x = minx + ( (uint16_t)i * stepx );
    }

    if ( j >= lut_length ) {
        loc_j = lut_length - 1u;
        p.y = maxy + 20u;
    } else {
        p.y = miny + ( (uint16_t)j * stepy );
    }

    p.weight = p_table[( loc_j * lut_length ) + loc_i];
    return p;
}

// A min/max/step look up table version of AWB_mesh
static uint16_t AWB_mesh_LUT( const awb_calibration_data_t *p_cali_data, uint16_t rg, uint16_t bg, uint16_t minx,
                              uint16_t maxx, uint16_t stepx, uint16_t miny, uint16_t maxy, uint16_t stepy,
                              const uint16_t *p_table )
{
    uint16_t res = 0;
    uint16_t lut_length = (uint16_t)p_cali_data->cali_rg_pos_len;
    uint16_t loc_rg = rg;
    uint16_t loc_bg = bg;
    uint16_t weight, db1, db2;
    uint16_t x, y;
    interp_2d_point_t p00, p01, p10, p11;

    if ( ( stepx != 0u ) && ( stepy != 0u ) ) {
        weight = 0;

        x = ( rg - minx ) / stepx; // division by zero is checked
        if ( rg < minx ) {
            x = 0;
            loc_rg = minx;
        } else if ( x > ( lut_length - 1u ) ) {
            x = lut_length - 1u;
            loc_rg = maxx;
        } else {
            ; /* No action required . MisraC rule 15.7 */
        }

        y = ( bg - miny ) / stepy; // division by zero is checked
        if ( bg < miny ) {
            y = 0;
            loc_bg = miny;
        } else if ( y > ( lut_length - 1u ) ) {
            y = lut_length - 1u;
            loc_bg = maxy;
        } else {
            ; /* No action required . MisraC rule 15.7 */
        }

        p00 = init_interp_2d_point_LUT( p_cali_data, x, y, minx, maxx, stepx, miny, maxy, stepy, p_table );
        p01 = init_interp_2d_point_LUT( p_cali_data, x + 1u, y, minx, maxx, stepx, miny, maxy, stepy, p_table );
        p10 = init_interp_2d_point_LUT( p_cali_data, x, y + 1u, minx, maxx, stepx, miny, maxy, stepy, p_table );
        p11 = init_interp_2d_point_LUT( p_cali_data, x + 1u, y + 1u, minx, maxx, stepx, miny, maxy, stepy, p_table );

        // NOTE: you changed these from rg/bg to irg/ibg
        db1 = (uint16_t)acamera_interpl_linear( (int32_t)loc_rg, (int32_t)p00.x, (int32_t)p00.weight, (int32_t)p01.x,
                                                (int32_t)p01.weight );
        db2 = (uint16_t)acamera_interpl_linear( (int32_t)loc_rg, (int32_t)p10.x, (int32_t)p10.weight, (int32_t)p11.x,
                                                (int32_t)p11.weight );

        weight = (uint16_t)acamera_interpl_linear( (int32_t)loc_bg, (int32_t)p00.y, (int32_t)db1, (int32_t)p10.y,
                                                   (int32_t)db2 );

        res = weight;
    } else {
        res = rg;
    }

    return res;
}

// Get weight for additional source light (defined by light_src)
static uint16_t mesh_AWB_getKnownSourceLight_weight_LUT( const awb_calibration_data_t *p_cali_data, uint16_t rg,
                                                         uint16_t bg, uint16_t light_rg, uint16_t light_bg )
{
    uint16_t lut_length = (uint16_t)p_cali_data->cali_rg_pos_len;

    uint16_t weight = 0;
    _Bool valid_points;
    // Coordinated of possible distribution of KnownSourceLight
    uint16_t MinX = ( light_rg > 30u ) ? ( light_rg - 30u ) : 0u;
    uint16_t MaxX = light_rg + 30u;
    uint16_t MinY = ( light_bg > 30u ) ? ( light_bg - 30u ) : 0u;
    uint16_t MaxY = light_bg + 30u;

    valid_points = ( rg >= MinX ) && ( rg <= MaxX ) && ( bg >= MinY ) && ( bg <= MaxY );

    if ( valid_points ) {
        uint16_t stepy = 0;
        uint16_t stepx = 0;
        if ( lut_length > 1u ) {
            stepy = ( MaxY - MinY ) / ( lut_length - 1u );
            stepx = ( MaxX - MinX ) / ( lut_length - 1u );
        }

        weight = AWB_mesh_LUT( p_cali_data, rg, bg, MinX, MaxX, stepx, MinY, MaxY, stepy,
                               p_cali_data->cali_mesh_ls_weight ); // division by zero is checked
    } else {
        weight = 0;
    }
    return weight;
}
//--- End mesh fetching functions -----
//================================================================================

#ifdef AWB_TEST_DATA
const uint16_t test_AVGrg = 167;
const uint16_t test_lux = 438;
const uint16_t rg_list[225] = {
    4095, 110, 113, 4095, 145, 146, 144, 130, 131, 135, 160, 154, 186, 225, 304, 4095, 112, 116, 115,
    120, 147, 150, 140, 142, 142, 148, 144, 185, 202, 224, 4095, 110, 113, 112, 126, 142, 146, 143,
    151, 161, 166, 170, 185, 195, 256, 144, 4095, 114, 116, 117, 142, 142, 134, 140, 167, 175, 189,
    192, 187, 221, 118, 4095, 109, 111, 117, 138, 142, 135, 129, 166, 172, 208, 226, 186, 174, 128,
    4095, 124, 114, 115, 134, 140, 134, 142, 170, 173, 211, 220, 190, 193, 144, 4095, 114, 116, 112,
    130, 129, 140, 151, 168, 162, 182, 222, 193, 209, 4095, 4095, 110, 117, 114, 118, 124, 134, 149,
    155, 136, 222, 232, 208, 218, 4095, 4095, 4095, 121, 110, 132, 146, 154, 141, 141, 144, 152, 154,
    242, 237, 4095, 134, 136, 121, 112, 140, 198, 181, 152, 152, 151, 193, 151, 4095, 220, 4095, 4095,
    4095, 4095, 180, 178, 189, 179, 165, 154, 200, 184, 212, 206, 219, 4095, 4095, 4095, 4095, 213, 192,
    192, 185, 230, 197, 204, 179, 195, 206, 191, 4095, 4095, 208, 4095, 4095, 173, 177, 178, 189, 188,
    186, 198, 195, 182, 188, 4095, 4095, 4095, 4095, 201, 4095, 4095, 185, 4095, 264, 206, 192, 191, 198,
    198, 4095, 4095, 182, 4095, 4095, 4095, 165, 175, 4095, 4095, 171, 4095, 4095, 245, 233};
const uint16_t bg_list[225] = {
    4095, 375, 339, 4095, 316, 281, 269, 272, 284, 298, 270, 277, 260, 290, 304, 4095, 338, 337, 320,
    312, 318, 284, 270, 266, 277, 299, 344, 259, 258, 298, 4095, 409, 358, 446, 321, 313, 297, 286,
    285, 282, 295, 298, 267, 255, 238, 4095, 4095, 363, 390, 374, 306, 317, 344, 309, 299, 286, 272,
    257, 243, 243, 832, 4095, 498, 433, 429, 319, 329, 403, 333, 318, 308, 267, 237, 237, 244, 512,
    4095, 265, 349, 342, 316, 345, 383, 327, 314, 311, 262, 247, 254, 254, 4095, 4095, 326, 349, 392,
    327, 376, 318, 332, 320, 317, 280, 233, 259, 248, 4095, 4095, 425, 362, 338, 408, 436, 313, 320,
    325, 302, 244, 237, 257, 245, 4095, 4095, 4095, 335, 315, 404, 325, 326, 393, 348, 307, 271, 261,
    244, 242, 4095, 348, 4095, 327, 322, 317, 252, 323, 324, 328, 273, 279, 282, 4095, 263, 4095, 4095,
    4095, 4095, 284, 296, 285, 305, 311, 310, 266, 294, 268, 245, 243, 4095, 4095, 4095, 4095, 254, 280,
    280, 296, 253, 306, 264, 306, 282, 269, 268, 4095, 4095, 4095, 4095, 4095, 287, 293, 294, 279, 281,
    292, 274, 278, 291, 277, 4095, 4095, 4095, 4095, 281, 4095, 4095, 278, 4095, 236, 258, 274, 273, 260,
    251, 4095, 4095, 285, 4095, 4095, 4095, 297, 297, 4095, 4095, 296, 4095, 4095, 368, 228};
const uint16_t awbsum_list[225] = {
    1, 352, 361, 1, 5774, 9345, 22368, 24103, 28465, 27352, 6645, 15524, 652, 127, 19,
    0, 6072, 5418, 180, 2535, 32656, 14015, 13889, 12827, 32380, 44656, 32587, 6042, 1839, 56,
    0, 179, 6124, 1394, 3296, 36653, 20349, 20385, 20463, 45124, 59282, 58005, 23631, 10450, 29481,
    9, 2, 1932, 5840, 10512, 31342, 26509, 24189, 24071, 52358, 13509, 36016, 25666, 50435, 60401,
    52, 0, 436, 5981, 7549, 36088, 24665, 38383, 22573, 49044, 44443, 50278, 16500, 38153, 45546,
    32, 2, 598, 8199, 727, 31626, 21719, 36816, 46929, 31411, 41719, 56808, 21441, 37951, 33373,
    27, 0, 5646, 11987, 98, 33632, 22246, 16415, 56141, 56533, 22521, 46428, 24779, 35069, 32814,
    0, 0, 319, 21238, 2433, 5163, 5817, 14381, 14709, 20957, 9165, 37020, 31565, 34387, 44714,
    0, 0, 0, 30161, 2070, 1567, 2790, 3670, 2583, 6641, 11503, 11098, 3504, 12762, 37567,
    3, 109, 17, 5486, 1249, 2065, 14798, 1273, 6585, 8755, 7848, 5043, 406, 0, 1253,
    0, 0, 0, 0, 18840, 37829, 31884, 17410, 27019, 1613, 8075, 20028, 7240, 8755, 7148,
    0, 0, 2, 0, 11188, 52206, 29874, 48571, 9642, 518, 8479, 28332, 31490, 19921, 5540,
    0, 0, 13, 4, 0, 2102, 13519, 23928, 22225, 15966, 18273, 41638, 37871, 38643, 45642,
    0, 1, 7, 6, 88, 5, 0, 244, 0, 281, 6277, 18480, 28732, 40855, 28454,
    0, 0, 285, 9, 0, 3, 279, 372, 1, 1, 816, 0, 0, 46, 614};
#endif


// Get average (rg&bg)
static void awb_calc_avg_weighted_gr_gb_mesh( awb_acamera_core_obj_t *p_awb_core_obj, const awb_stats_data_t *stats,
                                              const awb_input_data_t *input )
{
    uint64_t sum = 0;
    uint32_t npcH = 0;
    uint32_t npcL = 0;
    uint32_t npcLsum = 0;
    uint32_t npcHsum = 0;

    uint64_t avg_RG = 0;
    uint64_t avg_BG = 0;
    uint64_t GRres = 0;
    uint64_t GBres = 0;
    int32_t temp_cal = 0;
    uint32_t store = 0;
    int32_t MinX = 0;
    int32_t MinY = 0;
    int32_t MaxX = 0;
    int32_t MaxY = 0;

    uint16_t weight = 0;
    uint16_t weight_ls = 0;
    uint16_t i = 0;
    uint16_t j = 0;
    uint16_t npccount = 0;
    uint32_t lux = 0;
    uint16_t rg = 0;
    uint16_t bg = 0;
    uint16_t p_rg_highTemp = 0;
    uint16_t p_rg_lowTemp = 0;
    uint16_t sky_cut_high = 0;
    uint16_t sky_cut_low = 0;
    uint16_t sky_cut_high_bg = 0;
    uint8_t *const mvalid = p_awb_core_obj->mvalid;
    uint8_t *const cwfzones = p_awb_core_obj->cwfzones;
    uint8_t *const npcHigh = p_awb_core_obj->npcHigh;
    uint8_t *const npcLow = p_awb_core_obj->npcLow;
    uint8_t *const sky_zones = p_awb_core_obj->sky_zones;
    uint16_t *const rg_valid = p_awb_core_obj->rg_valid;
    uint16_t *const bg_valid = p_awb_core_obj->bg_valid;
    uint32_t *const p_weight = p_awb_core_obj->weight_;
    uint8_t npcHmean = 0;
    uint8_t npcLmean = 0;
    _Bool valid_zone = (_Bool)0;
    _Bool clipRG = (_Bool)0;
    _Bool clipBG = (_Bool)0;

    uint8_t p_highTemp = 50;
    uint8_t p_lowTemp = 50;
    uint8_t adjust_sky = 0;

    // coverity[misra_c_2012_rule_11_5_violation] input pointers are stored as void*
    const awb_acamera_input_t *p_acamera_input = (awb_acamera_input_t *)input->acamera_input;
    const awb_calibration_data_t *p_cali_data = &( p_acamera_input->cali_data );
    uint16_t( *calibration_light_src )[2] = p_cali_data->cali_light_src;

    if ( p_awb_core_obj->internal_inited == 0u ) {
        p_awb_core_obj->internal_inited = 1u;
    }


    // Set the min/max temperatures and their gains:
    if ( p_cali_data->cali_color_temp[0] != 0u ) {
        p_awb_core_obj->max_temp = 1000000 / (int32_t)p_cali_data->cali_color_temp[0]; // division by zero is checked
    }

    if ( p_cali_data->cali_color_temp[p_cali_data->cali_color_temp_len - 1u] != 0u ) {
        p_awb_core_obj->min_temp =
            1000000 /
            (int32_t)p_cali_data->cali_color_temp[p_cali_data->cali_color_temp_len - 1u]; // division by zero is checked
    }

    if ( p_cali_data->cali_ct_rg_pos_calc[0] != 0u ) {
        p_awb_core_obj->max_temp_rg = U16_MAX / p_cali_data->cali_ct_rg_pos_calc[0]; // division by zero is checked
    }

    if ( p_cali_data->cali_ct_bg_pos_calc[0] != 0u ) {
        p_awb_core_obj->max_temp_bg = U16_MAX / p_cali_data->cali_ct_bg_pos_calc[0]; // division by zero is checked
    }

    if ( p_cali_data->cali_ct_rg_pos_calc[p_cali_data->cali_ct_rg_pos_calc_len - 1u] != 0u ) {
        p_awb_core_obj->min_temp_rg =
            U16_MAX /
            p_cali_data->cali_ct_rg_pos_calc[p_cali_data->cali_ct_rg_pos_calc_len - 1u]; // division by zero is checked
    }

    if ( p_cali_data->cali_ct_bg_pos_calc[p_cali_data->cali_ct_bg_pos_calc_len - 1u] != 0u ) {
        p_awb_core_obj->min_temp_bg =
            U16_MAX /
            p_cali_data->cali_ct_bg_pos_calc[p_cali_data->cali_ct_bg_pos_calc_len - 1u]; // division by zero is checked
    }


#ifdef AWB_PRINT_DEBUG
    static uint16_t ittcount = 0;
    const uint16_t debugprintperiod = AWB_PRINT_DEBUG;
    ittcount++;
    if ( ittcount > debugprintperiod ) ittcount = 0;
#endif
    //
    // - Initialisation
    //

    for ( i = 0; i < stats->zones_size; ++i ) {
        p_weight[i] = 0;
        mvalid[i] = 0;
        cwfzones[i] = 0;
        sky_zones[i] = 1;
        npcLow[i] = 0;
        npcHigh[i] = 0;
    }

#ifdef AWB_TEST_DATA
    for ( i = 0; i < stats->zones_size; ++i ) {
        stats->awb_zones[i].rg = U16_MAX / rg_list[i];
        stats->awb_zones[i].bg = U16_MAX / bg_list[i];
        stats->awb_zones[i].sum = awbsum_list[i];
    }
    lux = test_lux;
#else
    // EV to lux LUT:
    if ( p_acamera_input->misc_info.cur_exposure_log2 < (int32_t)p_cali_data->cali_evtolux_ev_lut[0] ) {
        lux = p_cali_data->cali_evtolux_lux_lut[0];
    } else if ( p_acamera_input->misc_info.cur_exposure_log2 >=
                (int32_t)p_cali_data->cali_evtolux_ev_lut[p_cali_data->cali_evtolux_ev_lut_len - 1u] ) {
        lux = p_cali_data->cali_evtolux_lux_lut[p_cali_data->cali_evtolux_lux_lut_len - 1u];
    } else {
        for ( i = 1; i < p_cali_data->cali_evtolux_ev_lut_len; i++ ) {
            if ( p_acamera_input->misc_info.cur_exposure_log2 < (int32_t)p_cali_data->cali_evtolux_ev_lut[i] ) {
                break;
            }
        }
        lux = (uint32_t)acamera_interpl_linear(
            p_acamera_input->misc_info.cur_exposure_log2, (int32_t)p_cali_data->cali_evtolux_ev_lut[i - 1u],
            (int32_t)p_cali_data->cali_evtolux_lux_lut[i - 1u], (int32_t)p_cali_data->cali_evtolux_ev_lut[i],
            (int32_t)p_cali_data->cali_evtolux_lux_lut[i] );
    }
#endif


    // - Calculate probabilities from tables
    const uint16_t p_lux_highTemp = luts_lux_high( lux );
    const uint16_t p_lux_lowTemp = luts_lux_low( lux );

    //======================================================
    // - Light Corner Points
    //======================================================

    MinX = (int32_t)acamera_min_u16( p_cali_data->cali_rg_pos[0], calibration_light_src[0][0] );
    MinY = (int32_t)acamera_min_u16( p_cali_data->cali_bg_pos[0], calibration_light_src[0][1] );

    MaxX = (int32_t)acamera_max_u16( p_cali_data->cali_rg_pos[p_cali_data->cali_rg_pos_len - 1u],
                                     calibration_light_src[0][0] );
    MaxY = (int32_t)acamera_max_u16( p_cali_data->cali_bg_pos[p_cali_data->cali_bg_pos_len - 1u],
                                     calibration_light_src[0][1] );

    for ( i = 1; i < p_acamera_input->cali_data.cali_light_src_len; i++ ) {
        if ( calibration_light_src[i][0] < (uint16_t)MinX ) {
            MinX = (int32_t)calibration_light_src[i][0];
        }

        if ( calibration_light_src[i][1] < (uint16_t)MinY ) {
            MinY = (int32_t)calibration_light_src[i][1];
        }

        if ( calibration_light_src[i][0] > (uint16_t)MaxX ) {
            MaxX = (int32_t)calibration_light_src[i][0];
        }

        if ( calibration_light_src[i][1] > (uint16_t)MaxY ) {
            MaxY = (int32_t)calibration_light_src[i][1];
        }
    }

    //
    // - Main loop:
    //
    npccount = 0u;
    npcHsum = 0u;
    npcLsum = 0u;

    for ( i = 0; i < stats->zones_size; i++ ) {
        rg = stats->awb_zones[i].rg;
        bg = stats->awb_zones[i].bg;

        // See if we're within the validity rectangle
        clipRG = ( ( rg >= (uint16_t)MinX ) && ( rg <= (uint16_t)MaxX ) );
        clipBG = ( ( bg >= (uint16_t)MinY ) && ( bg <= (uint16_t)MaxY ) );
        valid_zone = ( clipRG && clipBG && ( stats->awb_zones[i].sum > 256u ) );

        if ( valid_zone ) {
            mvalid[i] = 1;
        } else {
            mvalid[i] = 0;
        }

        if ( valid_zone ) {

            weight = AWB_mesh( p_cali_data, rg, bg, p_cali_data->cali_rg_pos, p_cali_data->cali_bg_pos,
                               p_cali_data->cali_mesh_rgbg_weight );

            // Extra light source probabilities
            for ( j = 0; j < p_acamera_input->cali_data.cali_light_src_len; j++ ) {
                weight_ls = mesh_AWB_getKnownSourceLight_weight_LUT( p_cali_data, rg, bg, calibration_light_src[j][0],
                                                                     calibration_light_src[j][1] );
                // +15 to stop false positives
                if ( ( weight_ls >= 20u ) && ( weight_ls > ( weight + 15u ) ) ) {
                    weight = weight_ls;
                    if ( j == 0u ) {
                        cwfzones[i] = 1;
                    }
                }
            }
            weight = acamera_max_u16( weight, 0u );
            if ( weight < 60u ) {
                // insignificant weight (Err_TOLERANCE_2)
                weight = 0;
                mvalid[i] = 0;
            } else {
                // significant weight
                p_weight[i] = (uint32_t)weight;

                p_rg_highTemp = luts_rg_high( rg );
                p_rg_lowTemp = luts_rg_low( rg );

                npcH = (uint32_t)p_highTemp * p_rg_highTemp * p_lux_highTemp;
                npcL = (uint32_t)p_lowTemp * p_rg_lowTemp * p_lux_lowTemp;
                store = npcH + npcL;
                if ( store != 0u ) {
                    npcHigh[i] = ( uint8_t )( ( 100u * npcH ) / store ); // division by zero is checked
                    npcLow[i] = ( uint8_t )( ( 100u * npcL ) / store );  // division by zero is checked
                } else {
                    npcHigh[i] = ( uint8_t )( 100u * npcH );
                    npcLow[i] = ( uint8_t )( 100u * npcL );
                }
                npcHsum += npcHigh[i];
                npcLsum += npcLow[i];
                npccount++;
            } // end significant weight

        } // end valid_zone

    } // end main loop


    //
    // - NBP decision
    //
    if ( npccount > 0u ) {
        npcHmean = (uint8_t)npcHsum / (uint8_t)npccount; // division by zero is checked
        npcLmean = (uint8_t)npcLsum / (uint8_t)npccount; // division by zero is checked
    } else {
        // No strong zones, allow the calculation to fail to last known
        // with the code below
        npcHmean = 50;
        npcLmean = 50;
    }

    uint8_t evtolux_probability_enable = p_cali_data->cali_evtolux_probability_enable[0];
    if ( evtolux_probability_enable == 0u ) {
        npcHmean = 50;
        npcLmean = 50;
        lux = 500;
    }

    p_awb_core_obj->p_high = npcHmean;
    p_awb_core_obj->p_low = npcLmean;

    const uint32_t enable_awb_mix_light = p_cali_data->cali_awb_mix_light_param->enable_awb_mix_light;
    const uint32_t lux_low = p_cali_data->cali_awb_mix_light_param->lux_low;
    const uint32_t lux_high = p_cali_data->cali_awb_mix_light_param->lux_high;
    const uint32_t contrast_threshold = p_cali_data->cali_awb_mix_light_param->contrast_threshold;
    const uint32_t bg_threshold = p_cali_data->cali_awb_mix_light_param->bg_threshold;
    const uint32_t bg_weight = p_cali_data->cali_awb_mix_light_param->bg_weight;
    const uint16_t rgHigh_LUT_max = (uint16_t)p_cali_data->cali_awb_mix_light_param->rgHigh_LUT_max;
    const uint16_t rgHigh_LUT_min = (uint16_t)p_cali_data->cali_awb_mix_light_param->rgHigh_LUT_min;
    uint16_t rg_weight = 0;

#ifdef AWB_PRINT_DEBUG
    const uint32_t print_debug = p_cali_data->cali_awb_mix_light_param->print_debug;
#endif

    if ( ( enable_awb_mix_light != 0u ) && ( lux > lux_low ) && ( lux < lux_high ) &&
         ( p_acamera_input->misc_info.iridix_contrast > contrast_threshold ) ) {

        for ( i = 0; i < stats->zones_size; i++ ) {
            rg = stats->awb_zones[i].rg;
            const size_t rghigh_lut_len = sizeof( rghigh_lut ) / sizeof( rghigh_lut[0] );
            rg_weight = luts_fetch_u16( rg, rgHigh_LUT_min, rgHigh_LUT_max, 1, rghigh_lut, rghigh_lut_len );
            rg_weight = ( 100u * rg_weight ) / (uint16_t)rghigh_lut[0];

            p_weight[i] = ( ( mvalid[i] != 0u ) ? ( p_weight[i] * rg_weight ) : 0u );

            bg = stats->awb_zones[i].bg;
            if ( bg > bg_threshold ) {
                p_weight[i] = ( ( mvalid[i] != 0u ) ? bg_weight : 0u );
            }
        }
    } else if ( ( ( npcHmean >= npcLmean ) && ( ( uint8_t )( npcHmean - npcLmean ) < 15u ) ) ||
                ( ( npcHmean < npcLmean ) && ( ( uint8_t )( npcLmean - npcHmean ) < 15u ) ) ) {
        // Case : probabilities are about the same
        if ( lux < 10u ) {
            // Low light
            for ( i = 0; i < stats->zones_size; i++ ) {
                if ( ( mvalid[i] != 0u ) &&
                     ( stats->awb_zones[i].rg >= p_cali_data->cali_ct_rg_pos_calc[p_cali_data->cali_ct65pos[0]] ) &&
                     ( stats->awb_zones[i].bg <=
                       p_cali_data
                           ->cali_ct_bg_pos_calc[p_cali_data->cali_ct65pos[0]] ) ) { // division by zero is checked
                    p_weight[i] = p_weight[i] * npcLow[i];
                } else {
                    p_weight[i] = 0;
                }
            }
        } else {
            // Not bright or dark
            for ( i = 0; i < stats->zones_size; i++ ) {
                p_weight[i] = ( ( mvalid[i] != 0u ) ? ( 100u * p_weight[i] ) : 0u );
            }
        }
    } else if ( npcLmean > npcHmean ) {
        // likely we're in a dark situation
        for ( i = 0; i < stats->zones_size; i++ ) {
            p_weight[i] = ( ( mvalid[i] != 0u ) ? ( p_weight[i] * npcLow[i] ) : 0u );
        }
    } else {
        // likely we're in a light situation

        if ( lux > p_cali_data->cali_sky_lux_th[0] ) {
            adjust_sky = 1;
        }

        avg_BG = 0;
        for ( i = 0; i < stats->zones_size; i++ ) {
            avg_BG += stats->awb_zones[i].bg;
        }
        if ( stats->zones_size != 0u ) {
            avg_BG /= stats->zones_size; // division by zero is checked
        }

        if ( ( lux > p_cali_data->cali_sky_lux_th[0] ) && ( avg_BG > 246u ) ) {
            // looks like a sky scene
            sky_cut_high = p_cali_data->cali_ct_rg_pos_calc[p_cali_data->cali_ct65pos[0]];

            for ( j = 25u; j <= 65u; j += 20u ) {
                // NOTE : these are flip rt to matlab to save on vaariables
                sky_cut_low = ( ( 950u + j ) *
                                ( ( p_cali_data->cali_ct_rg_pos_calc[p_cali_data->cali_ct40pos[0]] + 256u ) >> 1 ) ) /
                              1000u; // division by zero is checked

                sky_cut_high_bg =
                    ( ( ( 950u + j ) > 1000u )
                          ? p_cali_data->cali_ct_bg_pos_calc[p_cali_data->cali_ct65pos[0]]
                          : ( ( ( 950u + j ) * p_cali_data->cali_ct_bg_pos_calc[p_cali_data->cali_ct65pos[0]] ) /
                              1000u ) ); // division by zero is checked

                sum = 0;
                for ( i = 0; i < stats->zones_size; i++ ) {
                    if ( ( stats->awb_zones[i].rg >= sky_cut_high ) && ( stats->awb_zones[i].rg <= sky_cut_low ) &&
                         ( stats->awb_zones[i].bg <= sky_cut_high_bg ) ) { // division by zero is checked
                        sky_zones[i] = 1;
                    } else {
                        sky_zones[i] = 0;
                    }
                    store = ( p_weight[i] ) * mvalid[i] * npcHigh[i] * sky_zones[i];
                    sum += store;
                }
                if ( sum != 0u ) {
                    break;
                }
            }
            for ( i = 0; i < stats->zones_size; i++ ) {
                p_weight[i] = p_weight[i] * mvalid[i] * npcHigh[i] * sky_zones[i];
            }

        } else {
            // general bright scene
            for ( i = 0; i < stats->zones_size; i++ ) {
                p_weight[i] = ( ( mvalid[i] != 0u ) ? ( p_weight[i] * npcHigh[i] ) : 0u );
            }
        }
    }

    //
    // - CWF
    //

    sum = 0;
    for ( i = 0; i < stats->zones_size; i++ ) {
        sum += cwfzones[i];
    }
    // strictly less-than to combat integer rounding
    if ( ( sum > ( (uint64_t)stats->zones_size >> 3 ) ) && ( npcLmean > npcHmean ) && ( lux > 100u ) &&
         ( lux <= 900u ) ) {
        // lots of CWF zones - keep CWF zones
        for ( i = 0; i < stats->zones_size; i++ ) {
            rg_valid[i] = stats->awb_zones[i].rg * mvalid[i] * cwfzones[i]; // division by zero is checked
            bg_valid[i] = stats->awb_zones[i].bg * mvalid[i] * cwfzones[i]; // division by zero is checked
            p_weight[i] = p_weight[i] * cwfzones[i];
        }
    } else if ( ( sum >= 1u ) && ( lux > 900u ) ) {
        // A few CWF zones - keep non-CWF zones
        for ( i = 0; i < stats->zones_size; i++ ) {
            {
                rg_valid[i] = stats->awb_zones[i].rg * mvalid[i] * ( 1u - cwfzones[i] ) *
                              sky_zones[i]; // division by zero is checked
                bg_valid[i] = stats->awb_zones[i].bg * mvalid[i] * ( 1u - cwfzones[i] ) *
                              sky_zones[i]; // division by zero is checked
                p_weight[i] = p_weight[i] * ( (uint32_t)1u - cwfzones[i] );
            }
        }
    } else {
        // Definately not CWF
        for ( i = 0; i < stats->zones_size; i++ ) {
            rg_valid[i] = stats->awb_zones[i].rg * mvalid[i] * sky_zones[i]; // division by zero is checked
            bg_valid[i] = stats->awb_zones[i].bg * mvalid[i] * sky_zones[i]; // division by zero is checked
        }
    }

    //
    // - norm_p checks
    //
    sum = 0;
    for ( i = 0; i < stats->zones_size; i++ ) {
        sum += (uint64_t)p_weight[i];
    }

    if ( sum == 0u ) {
        // no valid zones
        avg_RG = 0;
        for ( i = 0; i < stats->zones_size; i++ ) {
            avg_RG += stats->awb_zones[i].rg;
        }

        if ( stats->zones_size != 0u ) {
            avg_RG /= stats->zones_size; // division by zero is checked
        }

        if ( avg_RG > p_cali_data->cali_ct_rg_pos_calc[p_cali_data->cali_ct30pos[0]] ) { // division by zero is checked
            avg_RG = p_cali_data->cali_ct_rg_pos_calc[p_cali_data->cali_ct30pos[0]];
            avg_BG = p_cali_data->cali_ct_bg_pos_calc[p_cali_data->cali_ct30pos[0]];
        } else {
            /*
             * TODO: Check if this is relevant
             * p_awb_core_obj->stable_avg_RG;
             * p_awb_core_obj->stable_avg_BG;
             */
            avg_RG = 256;
            avg_BG = 256;
        }
    } else {
        // at least some valid zones
        avg_RG = 0;
        avg_BG = avg_RG;
        for ( i = 0; i < stats->zones_size; i++ ) {
            avg_RG += rg_valid[i] * (uint64_t)p_weight[i];
            avg_BG += bg_valid[i] * (uint64_t)p_weight[i];
        }

        avg_BG /= sum; // division by zero is checked
        avg_RG /= sum; // division by zero is checked

        // To Store the last stable Light Source.
        p_awb_core_obj->stable_avg_BG = (uint32_t)avg_BG;
        p_awb_core_obj->stable_avg_RG = (uint32_t)avg_RG;
    }

    //
    // - adjust sky
    //
    if ( ( adjust_sky != 0u ) && ( p_cali_data->cali_wb_strength[2] != 0u ) ) {
        avg_RG = ( p_cali_data->cali_wb_strength[0] * avg_RG ) /
                 p_cali_data->cali_wb_strength[2]; // division by zero is checked
        avg_BG = ( p_cali_data->cali_wb_strength[1] * avg_BG ) /
                 p_cali_data->cali_wb_strength[2]; // division by zero is checked
    }
    // if we have no clue what to do - do nothing!!!
    avg_RG = ( ( avg_RG != 0u ) ? avg_RG : p_awb_core_obj->stable_avg_RG );
    avg_BG = ( ( avg_BG != 0u ) ? avg_BG : p_awb_core_obj->stable_avg_BG );


    if ( ( avg_RG != 0u ) && ( avg_BG != 0u ) ) {
        GRres = U16_MAX / avg_RG; // division by zero is checked
        GBres = U16_MAX / avg_BG; // division by zero is checked


#ifdef AWB_BG_MAX_GAIN
        // Clip maxium gains for rg and bg according to gain
        const uint16_t max_bg_gain =
            acamera_calc_modulation_u16( p_acamera_input->misc_info.log2_gain, p_cali_data->cali_awb_bg_max_gain,
                                         p_cali_data->cali_awb_bg_max_gain_len );
        if ( GBres > max_bg_gain ) {
            GBres = max_bg_gain;
        }
#endif /*AWB_BG_MAX_GAIN*/


    } else {
        ; /* No action required . MisraC rule 15.7 */
    }

    /*
     * AWB convergence
     * We consider (GRres, GBres) the new AWB gains targets
     * If they differ significantly than the current gains AWB is not convergent
     */
    uint32_t awb_tolerance = 8;
    p_awb_core_obj->awb_converged = 1;

    if ( acamera_abs_int32( (int32_t)GRres - (int32_t)p_awb_core_obj->avg_GR ) > awb_tolerance ) {
        p_awb_core_obj->awb_converged = 0;
    }

    if ( acamera_abs_int32( (int32_t)GBres - (int32_t)p_awb_core_obj->avg_GB ) > awb_tolerance ) {
        p_awb_core_obj->awb_converged = 0;
    }

#ifdef AWB_SMOOTH_FILTER
    interp_2d_point_t point;
    fifo_push( p_awb_core_obj, p_cali_data, (uint16_t)GRres, (uint16_t)GBres );
    point = get_point( p_awb_core_obj, p_cali_data );
    p_awb_core_obj->avg_GR = (uint32_t)point.x;
    p_awb_core_obj->avg_GB = (uint32_t)point.y;


#else
    p_awb_core_obj->avg_GR = GRres;
    p_awb_core_obj->avg_GB = GBres;
#endif


#ifdef AWB_PRINT_DEBUG
    clipRG = 0;
#endif

    if ( p_acamera_input->misc_info.global_manual_awb == 0u ) {

        // Only set the values if we're not in manual mode
        if ( ( p_awb_core_obj->avg_GR != 0u ) && ( p_awb_core_obj->avg_GB != 0u ) ) {
            const uint16_t avg_GR = (uint16_t)p_awb_core_obj->avg_GR;
            const uint16_t avg_GB = (uint16_t)p_awb_core_obj->avg_GB;
            temp_cal = (int32_t)AWB_mesh( p_cali_data, ( U16_MAX / avg_GR ), ( U16_MAX / avg_GB ),
                                          p_cali_data->cali_rg_pos, p_cali_data->cali_bg_pos,
                                          p_cali_data->cali_mesh_color_temperature ); // division by zero is checked
            if ( temp_cal != 0 ) {
                temp_cal = 1000000 / temp_cal; // division by zero is checked
            }

            if ( temp_cal < p_awb_core_obj->min_temp ) {
#ifdef AWB_PRINT_DEBUG
                clipRG = 1;
#endif
                temp_cal = p_awb_core_obj->min_temp;
                p_awb_core_obj->rg_coef = p_awb_core_obj->min_temp_rg;
                p_awb_core_obj->bg_coef = p_awb_core_obj->min_temp_bg;

            } else if ( temp_cal > p_awb_core_obj->max_temp ) {
#ifdef AWB_PRINT_DEBUG
                clipRG = 2;
#endif
                temp_cal = p_awb_core_obj->max_temp;
                p_awb_core_obj->rg_coef = p_awb_core_obj->max_temp_rg;
                p_awb_core_obj->bg_coef = p_awb_core_obj->max_temp_bg;

            } else {
                p_awb_core_obj->rg_coef = avg_GR;
                p_awb_core_obj->bg_coef = avg_GB;
            }
        }
    } else {
        rg = ( p_awb_core_obj->rg_coef != 0u ) ? ( U16_MAX / p_awb_core_obj->rg_coef ) : U16_MAX;
        bg = ( p_awb_core_obj->bg_coef != 0u ) ? ( U16_MAX / p_awb_core_obj->bg_coef ) : U16_MAX;
        temp_cal = (int32_t)AWB_mesh( p_cali_data, rg, bg, p_cali_data->cali_rg_pos, p_cali_data->cali_bg_pos,
                                      p_cali_data->cali_mesh_color_temperature ); // division by zero is checked
        if ( temp_cal != 0 ) {
            temp_cal = 1000000 / temp_cal; // division by zero is checked
        }

        // moved from awb_normalise() func: update rg/bg coef in manual mode for next frame calculation
        p_awb_core_obj->rg_coef = p_acamera_input->misc_info.global_awb_red_gain;
        p_awb_core_obj->bg_coef = p_acamera_input->misc_info.global_awb_blue_gain;
    }

    p_awb_core_obj->temperature_detected = temp_cal;
}

//    For CCM switching
static void awb_detect_light_source( awb_acamera_core_obj_t *p_awb_core_obj )
{
    p_awb_core_obj->light_source_candidate = AWB_LIGHT_SOURCE_UNKNOWN;
    if ( p_awb_core_obj->temperature_detected <= AWB_DLS_LIGHT_SOURCE_A_D40_BORDER ) {
        p_awb_core_obj->light_source_candidate = AWB_LIGHT_SOURCE_A;
    } else if ( p_awb_core_obj->temperature_detected <= AWB_DLS_LIGHT_SOURCE_D40_D50_BORDER ) {
        p_awb_core_obj->light_source_candidate = AWB_LIGHT_SOURCE_D40;
    } else {
        p_awb_core_obj->light_source_candidate = AWB_LIGHT_SOURCE_D50;
    }
}

static void awb_calculate_warming_effect( awb_acamera_core_obj_t *p_awb_core_obj,
                                          const awb_calibration_data_t *p_cali_data )
{
    /*
        This function drives the cooling warming effect according to colour temperature.
        See kruithof curve for a reference and background theory about this functionality
        Tuning luts default
        CALIBRATION_AWB_WARMING_LS_A = {256,256,256}; ( u4.8 )
        CALIBRATION_AWB_WARMING_LS_D50= {256,256,256};( u4.8 )
        CALIBRATION_AWB_WARMING_LS_D75= {256,256,256};( u4.8 )
        AWB_colour_preference={7500,6000,4700,2800};  ( in Kelvin )

        | blue gain
        |    .                    .    .
        |        .            .
        |            . .  . .
        |        .              .
        |Red. gain                        .
        |.                            .
        -----|------|------|--------|-------
            70000  6000    4700     2800    CCT in kelvin
    */

    int32_t temperature = p_awb_core_obj->temperature_detected;
    uint32_t tmp = (uint32_t)p_cali_data->cali_awb_warming_ls_a[0] << 8;
    p_awb_core_obj->awb_warming_A[0] = (int32_t)tmp;
    tmp = (uint32_t)p_cali_data->cali_awb_warming_ls_a[1] << 8;
    p_awb_core_obj->awb_warming_A[1] = (int32_t)tmp;
    tmp = (uint32_t)p_cali_data->cali_awb_warming_ls_a[2] << 8;
    p_awb_core_obj->awb_warming_A[2] = (int32_t)tmp;

    tmp = (uint32_t)p_cali_data->cali_awb_warming_ls_d75[0] << 8;
    p_awb_core_obj->awb_warming_D75[0] = (int32_t)tmp;
    tmp = (uint32_t)p_cali_data->cali_awb_warming_ls_d75[1] << 8;
    p_awb_core_obj->awb_warming_D75[1] = (int32_t)tmp;
    tmp = (uint32_t)p_cali_data->cali_awb_warming_ls_d75[2] << 8;
    p_awb_core_obj->awb_warming_D75[2] = (int32_t)tmp;

    tmp = (uint32_t)p_cali_data->cali_awb_warming_ls_d50[0] << 8;
    p_awb_core_obj->awb_warming_D50[0] = (int32_t)tmp;
    tmp = (uint32_t)p_cali_data->cali_awb_warming_ls_d50[1] << 8;
    p_awb_core_obj->awb_warming_D50[1] = (int32_t)tmp;
    tmp = (uint32_t)p_cali_data->cali_awb_warming_ls_d50[2] << 8;
    p_awb_core_obj->awb_warming_D50[2] = (int32_t)tmp;

    // calibration table: AWB Colour preference
    const uint16_t *AWB_colour_preference = p_cali_data->cali_awb_colour_preference;
    int32_t m = 0;
    if ( temperature >= (int32_t)AWB_colour_preference[1] ) {
        // high temp

        // RED
        int32_t awb_red_pref = (int32_t)AWB_colour_preference[1] - (int32_t)AWB_colour_preference[0];
        if ( awb_red_pref == 0 ) {
            awb_red_pref = 1;
        }

        m = ( p_awb_core_obj->awb_warming_D50[0] - p_awb_core_obj->awb_warming_D75[0] ) / awb_red_pref;
        if ( m == 0 ) {
            p_awb_core_obj->awb_warming[0] = acamera_signed_right_shift( p_awb_core_obj->awb_warming_D50[0], 8 );
        } else {
            p_awb_core_obj->awb_warming[0] = acamera_signed_right_shift(
                ( ( m * ( temperature - (int32_t)AWB_colour_preference[0] ) ) + p_awb_core_obj->awb_warming_D75[0] ),
                8 );
        }

        // GREEN
        int32_t awb_green_pref = (int32_t)AWB_colour_preference[1] - (int32_t)AWB_colour_preference[0];
        if ( awb_green_pref == 0 ) {
            awb_green_pref = 1;
        }
        m = ( p_awb_core_obj->awb_warming_D50[1] - p_awb_core_obj->awb_warming_D75[1] ) / awb_green_pref;
        if ( m == 0 ) {
            p_awb_core_obj->awb_warming[1] = acamera_signed_right_shift( p_awb_core_obj->awb_warming_D50[1], 8 );
        } else {
            p_awb_core_obj->awb_warming[1] = acamera_signed_right_shift(
                ( ( m * ( temperature - (int32_t)AWB_colour_preference[0] ) ) + p_awb_core_obj->awb_warming_D75[1] ),
                8 );
        }
        // BLUE
        int32_t awb_blue_pref = (int32_t)AWB_colour_preference[1] - (int32_t)AWB_colour_preference[0];
        if ( awb_blue_pref == 0 ) {
            awb_blue_pref = 1;
        }
        m = ( p_awb_core_obj->awb_warming_D50[2] - p_awb_core_obj->awb_warming_D75[2] ) / awb_blue_pref;
        if ( m == 0 ) {
            p_awb_core_obj->awb_warming[2] = acamera_signed_right_shift( p_awb_core_obj->awb_warming_D50[2], 8 );
        } else {
            p_awb_core_obj->awb_warming[2] = acamera_signed_right_shift(
                ( ( m * ( temperature - (int32_t)AWB_colour_preference[0] ) ) + p_awb_core_obj->awb_warming_D75[2] ),
                8 );
        }

    } else if ( temperature <= (int32_t)AWB_colour_preference[2] ) {
        // low temp
        int32_t awb_red_pref = (int32_t)AWB_colour_preference[3] - (int32_t)AWB_colour_preference[2];
        if ( awb_red_pref == 0 ) {
            awb_red_pref = 1;
        }
        m = ( p_awb_core_obj->awb_warming_A[0] - p_awb_core_obj->awb_warming_D50[0] ) / awb_red_pref;
        if ( m == 0 ) {
            p_awb_core_obj->awb_warming[0] = acamera_signed_right_shift( p_awb_core_obj->awb_warming_D50[0], 8 );
        } else {
            p_awb_core_obj->awb_warming[0] = acamera_signed_right_shift(
                ( ( m * ( temperature - (int32_t)AWB_colour_preference[3] ) ) + p_awb_core_obj->awb_warming_A[0] ), 8 );
        }
        // GREN
        int32_t awb_green_pref = (int32_t)AWB_colour_preference[3] - (int32_t)AWB_colour_preference[2];
        if ( awb_green_pref == 0 ) {
            awb_green_pref = 1;
        }
        m = ( p_awb_core_obj->awb_warming_A[1] - p_awb_core_obj->awb_warming_D50[1] ) / awb_green_pref;
        if ( m == 0 ) {
            p_awb_core_obj->awb_warming[1] = acamera_signed_right_shift( p_awb_core_obj->awb_warming_D50[1], 8 );
        } else {
            p_awb_core_obj->awb_warming[1] = acamera_signed_right_shift(
                ( ( m * ( temperature - (int32_t)AWB_colour_preference[3] ) ) + p_awb_core_obj->awb_warming_A[1] ), 8 );
        }
        // BLUE
        int32_t awb_blue_pref = (int32_t)AWB_colour_preference[3] - (int32_t)AWB_colour_preference[2];
        if ( awb_blue_pref == 0 ) {
            awb_blue_pref = 1;
        }
        m = ( p_awb_core_obj->awb_warming_A[2] - p_awb_core_obj->awb_warming_D50[2] ) / awb_blue_pref;
        if ( m == 0 ) {
            p_awb_core_obj->awb_warming[2] = acamera_signed_right_shift( p_awb_core_obj->awb_warming_D50[2], 8 );
        } else {
            p_awb_core_obj->awb_warming[2] = acamera_signed_right_shift(
                ( ( m * ( temperature - (int32_t)AWB_colour_preference[3] ) ) + p_awb_core_obj->awb_warming_A[2] ), 8 );
        }
    } else {
        // mid temp
        p_awb_core_obj->awb_warming[0] = acamera_signed_right_shift( p_awb_core_obj->awb_warming_D50[0], 8 );
        p_awb_core_obj->awb_warming[1] = acamera_signed_right_shift( p_awb_core_obj->awb_warming_D50[1], 8 );
        p_awb_core_obj->awb_warming[2] = acamera_signed_right_shift( p_awb_core_obj->awb_warming_D50[2], 8 );
    }
}

// coverity[misra_c_2012_rule_8_7_violation], part of the API
void *awb_acamera_core_init( uint32_t ctx_id )
{
    static awb_acamera_core_obj_t awb_core_objs[FIRMWARE_CONTEXT_NUMBER];
    awb_acamera_core_obj_t *p_awb_core_obj = NULL;

    if ( ctx_id < (uint32_t)FIRMWARE_CONTEXT_NUMBER ) {
        p_awb_core_obj = &awb_core_objs[ctx_id];
        (void)memset( p_awb_core_obj, 0, sizeof( *p_awb_core_obj ) );

        p_awb_core_obj->stable_avg_RG = D50_DEFAULT;
        p_awb_core_obj->stable_avg_BG = D50_DEFAULT;
        p_awb_core_obj->avg_GR = 128;
        p_awb_core_obj->avg_GB = 128;

        p_awb_core_obj->max_temp = 10000;
        p_awb_core_obj->min_temp = 2100;
        p_awb_core_obj->max_temp_rg = 256;
        p_awb_core_obj->max_temp_bg = 256;
        p_awb_core_obj->min_temp_rg = 256;
        p_awb_core_obj->min_temp_bg = 256;

        p_awb_core_obj->internal_inited = 0;
    }

    return p_awb_core_obj;
}


// coverity[misra_c_2012_rule_8_7_violation], part of the API
int32_t awb_acamera_core_deinit( const void *awb_ctx )
{
    int32_t ret = 0;

    if ( awb_ctx == NULL ) {
        ret = -1;
    }

    return ret;
}

// coverity[misra_c_2012_rule_8_7_violation], part of the API
int32_t awb_acamera_core_proc( void *awb_ctx, const awb_stats_data_t *const stats, const awb_input_data_t *const input,
                               const awb_output_data_t *const output )
{
    int32_t ret = 0;

    if ( ( awb_ctx == NULL ) || ( stats == NULL ) || ( input == NULL ) || ( input->acamera_input == NULL ) ||
         ( output == NULL ) || ( output->acamera_output == NULL ) ) {
        ret = -1;
    }

    if ( ret == 0 ) {
        if ( stats->zones_size > MAX_AWB_ZONES ) {
            ret = -2;
        }
    }

    if ( ret == 0 ) {
        // coverity[misra_c_2012_rule_11_5_violation] User context is stored as void*
        awb_acamera_core_obj_t *p_awb_core_obj = (awb_acamera_core_obj_t *)awb_ctx;

        // coverity[misra_c_2012_rule_11_5_violation] input pointers are stored as void*
        const awb_acamera_input_t *p_acamera_input = (awb_acamera_input_t *)input->acamera_input;
        const awb_calibration_data_t *p_cali_data = &( p_acamera_input->cali_data );

        // coverity[misra_c_2012_rule_11_5_violation] output pointers are stored as void*
        awb_acamera_output_t *p_acamera_output = (awb_acamera_output_t *)output->acamera_output;

        awb_calc_avg_weighted_gr_gb_mesh( p_awb_core_obj, stats, input );
        awb_detect_light_source( p_awb_core_obj );
        awb_calculate_warming_effect( p_awb_core_obj, p_cali_data );

        {
            p_acamera_output->rg_coef = p_awb_core_obj->rg_coef;
            p_acamera_output->bg_coef = p_awb_core_obj->bg_coef;
            p_acamera_output->temperature_detected = p_awb_core_obj->temperature_detected;
            p_acamera_output->p_high = p_awb_core_obj->p_high;
            p_acamera_output->light_source_candidate = p_awb_core_obj->light_source_candidate;
            (void)memcpy( p_acamera_output->awb_warming, p_awb_core_obj->awb_warming,
                          sizeof( p_acamera_output->awb_warming ) );
            p_acamera_output->awb_converged = p_awb_core_obj->awb_converged;
        }
    }

    return ret;
}
