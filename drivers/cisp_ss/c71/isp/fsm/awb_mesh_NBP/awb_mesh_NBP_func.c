//----------------------------------------------------------------------------
//   The confidential and proprietary information contained in this file may
//   only be used by a person authorised under and to the extent permitted
//   by a subsisting licensing agreement from ARM Limited or its affiliates.
//
//          (C) COPYRIGHT [2019] ARM Limited or its affiliates.
//              ALL RIGHTS RESERVED
//
//   This entire notice must be reproduced on all copies of this file
//   and copies of this file may only be made by a person if such person is
//   permitted to do so under the terms of a subsisting license agreement
//   from ARM Limited or its affiliates.
//----------------------------------------------------------------------------

/*
	Auto White Balance module:
		1. Plankian curve based
		2. Mesh lookup table based
		3. NBP decision tables

	Controls:
		AWB_SMOOTH_FILTER 	- Enable smooth filter (fifo depth is FIFO_DEPTH)
		AWB_PRINT_DEBUG		- Enable test mode (with tracing debug information)
		AWB_TEST_DATA       - Runs test data through the system
		AWB_SIM_OLD_MESH    - Change probablities to simulation old awb mesh algorithm

	Default configuration:
		AWB_SMOOTH_FILTER - disable
		AWB_PRINT_DEBUG	  - disable
		AWB_TEST_DATA     - disable
		AWB_SIM_OLD_MESH  - disable

	Sensor-depended DATA SECTION:	(TBD: DATA SECTION should be generated by the calibration tool)
		1. light_src
		2. rg_pos
		3. bg_pos
		4. rgbg_weight
		5. rgbg_ls_weight
		6. color_temp_mesh
		7. p_rg_low
		8. p_rg_high
		9. p_lux_low
		10. p_lux_high
		11. color_temp
		12. ct_rg_pos_calc
		13. ct_bg_pos_calc

	Structure of the module:
		1. Controls
		2. DATA SECTION (see $SENSOR_mesh_lookup.h)
		3. Routines
		4. AWB functions (calling order:  awb.scxml)


*/

#include "system_assert.h"
#include "system_stdlib.h"
#include "3a/awb/awb_acamera_core.h"
#include "acamera_isp_core_settings.h"
#include "acamera_isp_ctx.h"
#include "acamera_logger.h"
#include "acamera_metering_mem_config.h"
#include "bitop.h"
#include "util_crc16.h"

#undef LOG_MODULE
#define LOG_MODULE LOG_MODULE_AWB_MESH_NBP

void *awb_acamera_core_init( uint32_t ctx_id )
{
	return NULL;
}

int32_t awb_acamera_core_proc( void *awb_ctx, const awb_stats_data_t *const stats, const awb_input_data_t *const input,
	const awb_output_data_t *const output )
{
	return 0;
}
////////////////////////////////////////////////////
// FSM function helpers
static void awb_fetch_calibration( AWB_fsm_ptr_t p_fsm, awb_calibration_data_t *p_cali )
{
    assert( p_cali );
    acamera_calib_mgr_entry_t *cm = ACAMERA_FSM2CM_PTR( p_fsm );

    p_cali->cali_awb_avg_coef = (uint8_t *)calib_mgr_u8_lut_get( cm, CALIBRATION_AWB_AVG_COEF );
    p_cali->cali_rg_pos = (uint16_t *)calib_mgr_u16_lut_get( cm, CALIBRATION_RG_POS );
    p_cali->cali_bg_pos = (uint16_t *)calib_mgr_u16_lut_get( cm, CALIBRATION_BG_POS );
    p_cali->cali_mesh_ls_weight = (uint16_t *)calib_mgr_u16_lut_get( cm, CALIBRATION_MESH_LS_WEIGHT );
    p_cali->cali_color_temp = (uint16_t *)calib_mgr_u16_lut_get( cm, CALIBRATION_COLOR_TEMP );
    p_cali->cali_ct_rg_pos_calc = (uint16_t *)calib_mgr_u16_lut_get( cm, CALIBRATION_CT_RG_POS_CALC );
    p_cali->cali_ct_bg_pos_calc = (uint16_t *)calib_mgr_u16_lut_get( cm, CALIBRATION_CT_BG_POS_CALC );
    p_cali->cali_evtolux_ev_lut = (uint32_t *)calib_mgr_u32_lut_get( cm, CALIBRATION_EVTOLUX_EV_LUT );
    p_cali->cali_evtolux_lux_lut = (uint32_t *)calib_mgr_u32_lut_get( cm, CALIBRATION_EVTOLUX_LUX_LUT );
    p_cali->cali_mesh_rgbg_weight = (uint16_t *)calib_mgr_u16_lut_get( cm, CALIBRATION_MESH_RGBG_WEIGHT );
    p_cali->cali_evtolux_probability_enable = (uint8_t *)calib_mgr_u8_lut_get( cm, CALIBRATION_EVTOLUX_PROBABILITY_ENABLE );
    p_cali->cali_sky_lux_th = (uint32_t *)calib_mgr_u32_lut_get( cm, CALIBRATION_SKY_LUX_TH );
    p_cali->cali_ct65pos = (uint16_t *)calib_mgr_u16_lut_get( cm, CALIBRATION_CT65POS );
    p_cali->cali_ct40pos = (uint16_t *)calib_mgr_u16_lut_get( cm, CALIBRATION_CT40POS );
    p_cali->cali_ct30pos = (uint16_t *)calib_mgr_u16_lut_get( cm, CALIBRATION_CT30POS );
    p_cali->cali_awb_mix_light_param = (awb_mixed_light_param_t *)calib_mgr_u32_lut_get( cm, CALIBRATION_AWB_MIXED_LIGHT_PARAMETERS );
    p_cali->cali_wb_strength = (uint16_t *)calib_mgr_u16_lut_get( cm, CALIBRATION_WB_STRENGTH );
    p_cali->cali_awb_bg_max_gain = (modulation_entry_t *)calib_mgr_mod16_lut_get( cm, CALIBRATION_AWB_BG_MAX_GAIN );
    p_cali->cali_mesh_color_temperature = (uint16_t *)calib_mgr_u16_lut_get( cm, CALIBRATION_MESH_COLOR_TEMPERATURE );
    p_cali->cali_awb_warming_ls_a = (uint16_t *)calib_mgr_u16_lut_get( cm, CALIBRATION_AWB_WARMING_LS_A );
    p_cali->cali_awb_warming_ls_d75 = (uint16_t *)calib_mgr_u16_lut_get( cm, CALIBRATION_AWB_WARMING_LS_D75 );
    p_cali->cali_awb_warming_ls_d50 = (uint16_t *)calib_mgr_u16_lut_get( cm, CALIBRATION_AWB_WARMING_LS_D50 );
    p_cali->cali_awb_colour_preference = (uint16_t *)calib_mgr_u16_lut_get( cm, CALIBRATION_AWB_WARMING_CCT );
    p_cali->cali_light_src = (calibration_light_src_t)calib_mgr_u16_lut_get( cm, CALIBRATION_LIGHT_SRC );
    p_cali->cali_awb_avg_coef_len = calib_mgr_lut_len( cm, CALIBRATION_AWB_AVG_COEF );
    p_cali->cali_rg_pos_len = calib_mgr_lut_len( cm, CALIBRATION_RG_POS );
    p_cali->cali_bg_pos_len = calib_mgr_lut_len( cm, CALIBRATION_BG_POS );
    p_cali->cali_color_temp_len = calib_mgr_lut_len( cm, CALIBRATION_COLOR_TEMP );
    p_cali->cali_ct_rg_pos_calc_len = calib_mgr_lut_len( cm, CALIBRATION_CT_RG_POS_CALC );
    p_cali->cali_ct_bg_pos_calc_len = calib_mgr_lut_len( cm, CALIBRATION_CT_BG_POS_CALC );
    p_cali->cali_evtolux_ev_lut_len = calib_mgr_lut_len( cm, CALIBRATION_EVTOLUX_EV_LUT );
    p_cali->cali_evtolux_lux_lut_len = calib_mgr_lut_len( cm, CALIBRATION_EVTOLUX_LUX_LUT );
    p_cali->cali_awb_bg_max_gain_len = calib_mgr_lut_rows( cm, CALIBRATION_AWB_BG_MAX_GAIN );
    p_cali->cali_light_src_len = calib_mgr_lut_rows( cm, CALIBRATION_LIGHT_SRC );
}

static void awb_fetch_misc_info( AWB_fsm_ptr_t p_fsm, awb_misc_info_t *p_misc )
{
    assert( p_misc );
    acamera_isp_ctx_ptr_t p_ictx = ACAMERA_FSM2ICTX_PTR( p_fsm );

    int32_t total_gain = 0; // Get the total gain from general rounter.
    int32_t cur_exposure_log2 = 0;
    WRAP_GENERAL_CMD( p_ictx, CMD_ID_CMOS_CURRENT_EXPOSURE_LOG2, CMD_DIRECTION_GET, NULL, (uint32_t *)&cur_exposure_log2 );
    WRAP_GENERAL_CMD( p_ictx, CMD_ID_CMOS_TOTAL_GAIN, CMD_DIRECTION_GET, NULL, (uint32_t *)&total_gain );

    p_misc->iridix_contrast = ACAMERA_FSM2FSMGR_PTR( p_fsm )->iridix_fsm.iridix_contrast;
    p_misc->log2_gain = ( uint16_t )( total_gain >> ( LOG2_GAIN_SHIFT - 8 ) );
    p_misc->cur_exposure_log2 = cur_exposure_log2;
    p_misc->global_manual_awb = get_context_param( p_ictx, SYSTEM_MANUAL_AWB_PARAM );
    p_misc->global_awb_red_gain = get_context_param( p_ictx, SYSTEM_AWB_RED_GAIN_PARAM );
    p_misc->global_awb_blue_gain = get_context_param( p_ictx, SYSTEM_AWB_BLUE_GAIN_PARAM );
}

static void awb_fetch_stats( AWB_fsm_ptr_t p_fsm, awb_stats_data_t *p_stats )
{
    assert( p_stats );

#if !USER_MODULE
    acamera_isp_ctx_ptr_t p_ictx = ACAMERA_FSM2ICTX_PTR( p_fsm );
    // in USER side, sbuf delivers curr_AWB_ZONES
    p_fsm->curr_AWB_ZONES = acamera_isp_metering_awb_nodes_used_horiz_read( p_ictx->settings.isp_base ) *
                            acamera_isp_metering_awb_nodes_used_vert_read( p_ictx->settings.isp_base );
#endif // !USER_MODULE

    p_stats->zones_size = p_fsm->curr_AWB_ZONES;
    p_stats->awb_zones = p_fsm->awb_zones;
}


static void awb_coeffs_write( const AWB_fsm_t *p_fsm )
{
    acamera_isp_out_format_rgb2rgb_coef_b_1_write( ACAMERA_FSM2ICTX_PTR( p_fsm )->settings.isp_base, p_fsm->awb_warming[0] );
    acamera_isp_out_format_rgb2rgb_coef_b_2_write( ACAMERA_FSM2ICTX_PTR( p_fsm )->settings.isp_base, p_fsm->awb_warming[1] );
    acamera_isp_out_format_rgb2rgb_coef_b_3_write( ACAMERA_FSM2ICTX_PTR( p_fsm )->settings.isp_base, p_fsm->awb_warming[2] );
}

#if !USER_MODULE
static void awb_roi_update( AWB_fsm_ptr_t p_fsm )
{
#ifdef ACAMERA_ISP_ZONES_AWB_WEIGHT_DEFAULT
    acamera_isp_ctx_ptr_t p_ictx = ACAMERA_FSM2ICTX_PTR( p_fsm );

    // Get packed (4 8-bit coordinates in 32-bit variable) ROI from param
    const uint32_t awb_roi = get_context_param( p_ictx, AWB_ROI_ID_PARAM );

    // Unpack and check values
    const uint32_t y2 = ( awb_roi & 0xff );
    const uint32_t x2 = ( ( awb_roi >> 8 ) & 0xff );
    const uint32_t y1 = ( ( awb_roi >> 16 ) & 0xff );
    const uint32_t x1 = ( ( awb_roi >> 24 ) & 0xff );

    if ( x2 <= x1 || y2 <= y1 ) {
        override_context_param( p_ictx, AWB_ROI_ID_PARAM, p_fsm->awb_roi );
        return;
    }

    p_fsm->awb_roi = awb_roi;

    uint16_t horz_zones = acamera_isp_metering_awb_nodes_used_horiz_read( p_ictx->settings.isp_base );
    uint16_t vert_zones = acamera_isp_metering_awb_nodes_used_vert_read( p_ictx->settings.isp_base );
    uint16_t x, y;

    const uint16_t *ptr_awb_zone_whgh_h = calib_mgr_u16_lut_get( p_ictx->calib_mgr_data, CALIBRATION_AWB_ZONE_WGHT_HOR );
    const uint16_t *ptr_awb_zone_whgh_v = calib_mgr_u16_lut_get( p_ictx->calib_mgr_data, CALIBRATION_AWB_ZONE_WGHT_VER );

    const uint8_t x_start = ( uint8_t )( ( x1 * horz_zones + 128 ) >> 8 );
    const uint8_t x_end = ( uint8_t )( ( x2 * horz_zones + 128 ) >> 8 );
    const uint8_t y_start = ( uint8_t )( ( y1 * vert_zones + 128 ) >> 8 );
    const uint8_t y_end = ( uint8_t )( ( y2 * vert_zones + 128 ) >> 8 );
    uint8_t zone_size_x = x_end - x_start;
    uint8_t zone_size_y = y_end - y_start;
    uint32_t middle_x = zone_size_x * 256 / 2;
    uint32_t middle_y = zone_size_y * 256 / 2;
    uint32_t len = calib_mgr_lut_len( p_ictx->calib_mgr_data, CALIBRATION_AWB_ZONE_WGHT_HOR );
    len = ( ( len > 0 ) ? len : 1 );
    uint32_t len_zone_wght_hor = ( horz_zones - 1 ) / len + 1;
    // uint32_t len_zone_wght_hor =  (horz_zones - 1) / calib_mgr_lut_len(ACAMERA_FSM2CM_PTR(p_fsm),CALIBRATION_AWB_ZONE_WGHT_HOR) + 1;

    len = calib_mgr_lut_len( p_ictx->calib_mgr_data, CALIBRATION_AWB_ZONE_WGHT_VER );
    len = ( ( len > 0 ) ? len : 1 );
    uint32_t len_zone_wght_ver = ( vert_zones - 1 ) / len + 1;
    // uint32_t len_zone_wght_ver = (vert_zones - 1) / calib_mgr_lut_len(ACAMERA_FSM2CM_PTR(p_fsm),CALIBRATION_AWB_ZONE_WGHT_VER) + 1;
    uint16_t scale_x = ( horz_zones - 1 ) / ( len_zone_wght_hor > 0 ? len_zone_wght_hor : 1 ) + 1;
    uint16_t scale_y = ( vert_zones - 1 ) / ( len_zone_wght_ver > 0 ? len_zone_wght_ver : 1 ) + 1;

    uint16_t gaus_center_x = ( len_zone_wght_hor * 256 / 2 ) * scale_x;
    uint16_t gaus_center_y = ( len_zone_wght_ver * 256 / 2 ) * scale_y;

    for ( y = 0; y < vert_zones; y++ ) {
        uint8_t awb_coeff = 0;
        for ( x = 0; x < horz_zones; x++ ) {
            if ( y >= y_start && y <= y_end &&
                 x >= x_start && x <= x_end ) {

                uint8_t index_y = ( y - y_start );
                uint8_t index_x = ( x - x_start );
                int32_t distance_x = ( index_x * 256 + 128 ) - middle_x;
                int32_t distance_y = ( index_y * 256 + 128 ) - middle_y;
                uint32_t coeff_x;
                uint32_t coeff_y;

                if ( ( x == x_end && x_start != x_end ) ||
                     ( y == y_end && y_start != y_end ) ) {
                    awb_coeff = 0;
                } else {
                    coeff_x = ( gaus_center_x + distance_x ) / 256;
                    if ( distance_x > 0 && ( distance_x & 0x80 ) )
                        coeff_x--;
                    coeff_y = ( gaus_center_y + distance_y ) / 256;
                    if ( distance_y > 0 && ( distance_y & 0x80 ) )
                        coeff_y--;

                    coeff_x = ptr_awb_zone_whgh_h[coeff_x / scale_x];
                    coeff_y = ptr_awb_zone_whgh_v[coeff_y / scale_y];

                    awb_coeff = ( coeff_x * coeff_y ) >> 4;
                    if ( awb_coeff > 1 )
                        awb_coeff--;
                }
            } else {
                awb_coeff = 0;
            }
            acamera_isp_zones_awb_weight_write( p_ictx->settings.isp_base, y, x, awb_coeff );
        }
    }
#else
    LOG( LOG_WARNING, "AWB does not have zone weights" );
#endif // ACAMERA_ISP_ZONES_AWB_WEIGHT_DEFAULT
}
#endif // !USER_MODULE


// For CCM switching.
static void awb_process_light_source( AWB_fsm_t *p_fsm )
{
    int32_t total_gain = 0;
    int high_gain = 0;
    acamera_cmd_ccm_info ccm_info;

    // Get the total gain from general rounter.
    if ( WRAP_GENERAL_CMD( ACAMERA_FSM2ICTX_PTR( p_fsm ), CMD_ID_CMOS_TOTAL_GAIN, CMD_DIRECTION_GET, NULL, (uint32_t *)&total_gain ) ) {
        return;
    }

    high_gain = ( total_gain >> ( LOG2_GAIN_SHIFT - 8 ) ) >= calib_mgr_u16_lut_get( ACAMERA_FSM2CM_PTR( p_fsm ), CALIBRATION_CCM_ONE_GAIN_THRESHOLD )[0];

    // Get the CCM info before use and update it
    if ( WRAP_GENERAL_CMD( ACAMERA_FSM2ICTX_PTR( p_fsm ), CMD_ID_CCM_INFO, CMD_DIRECTION_GET, NULL, (uint32_t *)&ccm_info ) ) {
        return;
    }

#if 0
    if( p_fsm->p_high > 60 ) {
        ++p_fsm->detect_light_source_frames_count;
        if( p_fsm->detect_light_source_frames_count >= p_fsm->switch_light_source_detect_frames_quantity ) {
#ifdef AWB_PRINT_DEBUG
            if( ccm_info.light_source != AWB_LIGHT_SOURCE_D50 ) {
                LOG( LOG_DEBUG, "Light source is changed" );
                LOG( LOG_DEBUG, "p_high=%d, using AWB_LIGHT_SOURCE_D50", p_fsm->p_high );
            }
#endif

            ccm_info.light_source_previous = ccm_info.light_source;
            ccm_info.light_source = p_fsm->light_source_candidate;
            ccm_info.light_source_ccm_previous = ccm_info.light_source_ccm;
            ccm_info.light_source_ccm = high_gain ? AWB_LIGHT_SOURCE_UNKNOWN : p_fsm->light_source_candidate; // For low light, set ccm = I.
            ccm_info.light_source_change_frames = p_fsm->switch_light_source_change_frames_quantity;
            ccm_info.light_source_change_frames_left = p_fsm->switch_light_source_change_frames_quantity;

            WRAP_GENERAL_CMD( ACAMERA_FSM2ICTX_PTR(p_fsm),  CMD_ID_CCM_INFO, CMD_DIRECTION_SET, (uint32_t *)&ccm_info, NULL);
        }

    } else
#endif
    if ( p_fsm->light_source_detected == p_fsm->light_source_candidate ) {
        if ( ( p_fsm->light_source_candidate != ccm_info.light_source ) || ( high_gain && ccm_info.light_source_ccm != AWB_LIGHT_SOURCE_UNKNOWN ) || ( !high_gain && ccm_info.light_source_ccm == AWB_LIGHT_SOURCE_UNKNOWN ) ) {
            ++p_fsm->detect_light_source_frames_count;
            //            LOG( LOG_DEBUG, "Bin size:%d", p_fsm->detect_light_source_frames_count );
            if ( p_fsm->detect_light_source_frames_count >= p_fsm->switch_light_source_detect_frames_quantity && !ccm_info.light_source_change_frames_left ) {
                ccm_info.light_source_previous = ccm_info.light_source;
                ccm_info.light_source = p_fsm->light_source_candidate;
                ccm_info.light_source_ccm_previous = ccm_info.light_source_ccm;
                ccm_info.light_source_ccm = high_gain ? AWB_LIGHT_SOURCE_UNKNOWN : p_fsm->light_source_candidate; // For low light, set ccm = I.
                ccm_info.light_source_change_frames = p_fsm->switch_light_source_change_frames_quantity;
                ccm_info.light_source_change_frames_left = p_fsm->switch_light_source_change_frames_quantity;
                WRAP_GENERAL_CMD( ACAMERA_FSM2ICTX_PTR( p_fsm ), CMD_ID_CCM_INFO, CMD_DIRECTION_SET, (uint32_t *)&ccm_info, NULL );
#ifdef AWB_PRINT_DEBUG
                // These are rarer so can print wherever they are fired (i.e. not dependent on ittcount).
                LOG( LOG_DEBUG, "Light source is changed" );
                if ( ccm_info.light_source == AWB_LIGHT_SOURCE_A )
                    LOG( LOG_DEBUG, "AWB_LIGHT_SOURCE_A" );
                if ( ccm_info.light_source == AWB_LIGHT_SOURCE_D40 )
                    LOG( LOG_DEBUG, "AWB_LIGHT_SOURCE_D40" );
                if ( ccm_info.light_source == AWB_LIGHT_SOURCE_D50 )
                    LOG( LOG_DEBUG, "AWB_LIGHT_SOURCE_D50" );
#endif
            }
        }
    } else {
        p_fsm->detect_light_source_frames_count = 0;
    }
    p_fsm->light_source_detected = p_fsm->light_source_candidate;
}


// Perform normalisation.
static void awb_normalise( AWB_fsm_t *p_fsm )
{
    int32_t wb[4];
    acamera_isp_ctx_ptr_t p_ictx = ACAMERA_FSM2ICTX_PTR( p_fsm );

    wb[0] = log2_fixed_to_fixed( calib_mgr_u16_lut_get( ACAMERA_FSM2CM_PTR( p_fsm ), CALIBRATION_STATIC_WB )[0], 8, LOG2_GAIN_SHIFT );
    wb[1] = log2_fixed_to_fixed( calib_mgr_u16_lut_get( ACAMERA_FSM2CM_PTR( p_fsm ), CALIBRATION_STATIC_WB )[1], 8, LOG2_GAIN_SHIFT );
    wb[2] = log2_fixed_to_fixed( calib_mgr_u16_lut_get( ACAMERA_FSM2CM_PTR( p_fsm ), CALIBRATION_STATIC_WB )[2], 8, LOG2_GAIN_SHIFT );
    wb[3] = log2_fixed_to_fixed( calib_mgr_u16_lut_get( ACAMERA_FSM2CM_PTR( p_fsm ), CALIBRATION_STATIC_WB )[3], 8, LOG2_GAIN_SHIFT );

    {
        if ( get_context_param( p_ictx, SYSTEM_MANUAL_AWB_PARAM ) ) {
            p_fsm->rg_coef = get_context_param( p_ictx, SYSTEM_AWB_RED_GAIN_PARAM );
            p_fsm->bg_coef = get_context_param( p_ictx, SYSTEM_AWB_BLUE_GAIN_PARAM );
        } else {
            set_context_param( p_ictx, SYSTEM_AWB_RED_GAIN_PARAM, p_fsm->rg_coef );
            set_context_param( p_ictx, SYSTEM_AWB_BLUE_GAIN_PARAM, p_fsm->bg_coef );
        }

        wb[0] += log2_fixed_to_fixed( p_fsm->rg_coef, 8, LOG2_GAIN_SHIFT );
        wb[3] += log2_fixed_to_fixed( p_fsm->bg_coef, 8, LOG2_GAIN_SHIFT );
    }
    {
        int i;
        int32_t min_wb = wb[0];
        for ( i = 1; i < 4; ++i ) {
            int32_t _wb = wb[i];
            if ( min_wb > _wb ) {
                min_wb = _wb;
            }
        }

        acamera_cmd_sensor_info sensor_info;
        if ( WRAP_GENERAL_CMD( ACAMERA_FSM2ICTX_PTR( p_fsm ), CMD_ID_SENSOR_INFO, CMD_DIRECTION_GET, NULL, (uint32_t *)&sensor_info ) ) {
            return;
        }

        uint8_t isp_input_bits = sensor_info.sensor_output_bits;
        int32_t diff = ( isp_input_bits << LOG2_GAIN_SHIFT ) - log2_fixed_to_fixed( ( 1 << isp_input_bits ) - sensor_info.black_level, 0, LOG2_GAIN_SHIFT ) - min_wb;
        for ( i = 0; i < 4; ++i ) {
            int32_t _wb = wb[i] + diff;
            p_fsm->wb_log2[i] = _wb;
        }
    }
}


////////////////////////////////////////////////////
// FSM event handlers

void awb_init( AWB_fsm_t *p_fsm )
{
    LOG( LOG_NOTICE, "AWB USING 3A LIB" );

    p_fsm->awb_core = awb_acamera_core_init( ACAMERA_FSM_GET_FW_ID( p_fsm ) );
    if ( p_fsm->awb_core == NULL )
        LOG( LOG_ERR, "Failed to initialize AWB core!" );

    LOG( LOG_INFO, "awb_init E" );

    // Initial AWB (rg,bg) is the identity.
    p_fsm->rg_coef = 0x100;
    p_fsm->bg_coef = 0x100;

    p_fsm->wb_log2[0] = 0;
    p_fsm->wb_log2[1] = 0;
    p_fsm->wb_log2[2] = 0;
    p_fsm->wb_log2[3] = 0;

    p_fsm->awb_roi = get_context_param( ACAMERA_FSM2ICTX_PTR( p_fsm ), AWB_ROI_ID_PARAM );

    /* Register init */
    acamera_isp_pipeline_awb_switch_write( ACAMERA_FSM2ICTX_PTR( p_fsm )->settings.isp_base, 1 );

    p_fsm->repeat_irq_mask = BIT( ACAMERA_IRQ_AWB_STATS );
    AWB_request_interrupt( p_fsm, p_fsm->repeat_irq_mask );

    /* Use the default stats mode. */
    acamera_isp_metering_awb_stats_mode_write( ACAMERA_FSM2ICTX_PTR( p_fsm )->settings.isp_base,
                                               ACAMERA_ISP_METERING_AWB_STATS_MODE_DEFAULT );

    LOG( LOG_INFO, "awb_init X" );
}

void awb_config( AWB_fsm_t *p_fsm )
{
    // Set the default AWB values
    if ( MAX_AWB_ZONES < acamera_isp_metering_awb_nodes_used_horiz_read( ACAMERA_FSM2ICTX_PTR( p_fsm )->settings.isp_base ) * acamera_isp_metering_awb_nodes_used_vert_read( ACAMERA_FSM2ICTX_PTR( p_fsm )->settings.isp_base ) ) {
        LOG( LOG_CRIT, "MAX_AWB_ZONES is less than hardware reported zones" );
    }

    awb_coeffs_write( p_fsm );
}

void awb_reload_calibration( AWB_fsm_t *p_fsm )
{

#if !USER_MODULE
    awb_roi_update( p_fsm );
#endif // !USER_MODULE

    awb_fetch_calibration( p_fsm, &p_fsm->awb_input.cali_data );
}


void awb_update_algo( AWB_fsm_t *p_fsm )
{
    awb_fetch_misc_info( p_fsm, &p_fsm->awb_input.misc_info );
    awb_fetch_stats( p_fsm, &p_fsm->awb_stats );

    const awb_input_data_t input = {.acamera_input = &p_fsm->awb_input};
    const awb_output_data_t output = {.acamera_output = &p_fsm->awb_output};

    int32_t err = awb_acamera_core_proc( p_fsm->awb_core, &p_fsm->awb_stats, &input, &output );

    if ( err == 0 ) {
        p_fsm->rg_coef = p_fsm->awb_output.rg_coef;
        p_fsm->bg_coef = p_fsm->awb_output.bg_coef;
        p_fsm->temperature_detected = p_fsm->awb_output.temperature_detected;
        p_fsm->p_high = p_fsm->awb_output.p_high;
        p_fsm->light_source_candidate = p_fsm->awb_output.light_source_candidate;
        system_memcpy( p_fsm->awb_warming, p_fsm->awb_output.awb_warming, sizeof( p_fsm->awb_warming ) );
    } else {
        LOG( LOG_ERR, "Failed process awb (error=%d)!", err );
    }

    awb_process_light_source( p_fsm );
    awb_normalise( p_fsm );

    /* There yet is no FSM waiting for this event.
     * FSMs such as CCM can have algo_update state separately from hw_update.
     */
    //fsm_raise_event( p_fsm, event_id_algo_awb_done );
}

void awb_update_hw( AWB_fsm_t *p_fsm )
{
    awb_coeffs_write( p_fsm );
}

void awb_deinit( AWB_fsm_ptr_t p_fsm )
{
    int32_t err = awb_acamera_core_deinit( p_fsm->awb_core );
    if ( err != 0 )
        LOG( LOG_ERR, "Failed to de-initialize AWB core (err=%d)!", err );
}


////////////////////////////////////////////////////
// Hardware interrupt hadler


#define AWB_STATS_SIZE ( 225 * 2 ) /*225 records of 64 bits*/
#define AWB_STATS_META_SIZE ( 4 )  /*meta data for statistics */
#define AWB_STATS_CRC_INDEX ( AWB_STATS_SIZE + AWB_STATS_META_SIZE - 1 )

#if STATISTICS_BUFFER_DATA_LOCALLY
static uint32_t l_statistics_data[AWB_STATS_SIZE + AWB_STATS_META_SIZE];
#endif /* STATISTICS_BUFFER_DATA_LOCALLY */

static uint32_t awb_get_data( const uint32_t base_address, const size_t index )
{
#if STATISTICS_BUFFER_DATA_LOCALLY
    (void)base_address;
    return l_statistics_data[index];
#else
    return system_isp_read_32( base_address +
                               ACAMERA_METERING_MEM_BASE_ADDR +
                               ISP_METERING_OFFSET_AWB +
                               ( index << 2 ) );
#endif /*STATISTICS_BUFFER_DATA_LOCALLY*/
}

static uint16_t awb_get_crc( const uint32_t base_address )
{
    uint16_t crc16 = 0xffff;
    size_t i;
    for ( i = 0; i < ( AWB_STATS_SIZE + AWB_STATS_META_SIZE - 1 ); ++i ) {
        const uint32_t data = awb_get_data( base_address, i );
        crc16 = acrc_ccitt_byte( crc16, BF_GET( data, 24, 8 ) );
        crc16 = acrc_ccitt_byte( crc16, BF_GET( data, 16, 8 ) );
        crc16 = acrc_ccitt_byte( crc16, BF_GET( data, 8, 8 ) );
        crc16 = acrc_ccitt_byte( crc16, BF_GET( data, 0, 8 ) );
    }

    return crc16;
}

static int awb_is_crc_valid( const uint32_t base_address )
{
    const uint32_t crc16 = awb_get_crc( base_address );
    /* The last entry in in a histogram set is the crc. */
    const uint32_t crc_hw = awb_get_data( base_address, AWB_STATS_CRC_INDEX );

    if ( crc16 != crc_hw ) {
        LOG( LOG_ERR, "No CRC match for awb 0x%x read, 0x%x calced", crc_hw, crc16 );
        return 0;
    }

    return 1;
}


static int awb_read_statistics( AWB_fsm_t *p_fsm )
{
    // Auto white balance statistics starts at address 1856 and contains up to 225 records of 64 bits each followed
    // by five 32-bit fields:
    // - Global R/G average (fix point 4.8 format)
    // - Global B/G average (fix point 4.8 format)
    // - Total averaged pixel count
    // - Frame counter
    // - CRC16
    // Each 64 bit record contains 2 16 bit fields corresponding to average R/G, B/G (fix point 4.8 format) in the
    // zone followed by 32-bit field for averaged pixel count.
    const uint32_t isp_base = ACAMERA_FSM2ICTX_PTR( p_fsm )->settings.isp_base;

#if STATISTICS_BUFFER_DATA_LOCALLY

    // This is a large IO operation which also blocks spinlocks accessing the
    // IO. We read all of the stats data to be able to checksum it but only some
    // of it will be used.
    system_isp_mem_read( l_statistics_data,
                         isp_base + ACAMERA_METERING_MEM_BASE_ADDR + ISP_METERING_OFFSET_AWB,
                         AWB_STATS_SIZE + AWB_STATS_META_SIZE,
                         sizeof( uint32_t ) );
#endif /* STATISTICS_BUFFER_DATA_LOCALLY */

    if ( !awb_is_crc_valid( isp_base ) ) {
        /* No further processing. */
        return -1;
    }

    // Process the awb hardware values.
    size_t awb_record;
    for ( awb_record = 0; awb_record < p_fsm->curr_AWB_ZONES; ++awb_record ) {
        const uint32_t data = awb_get_data( isp_base, awb_record << 1 );
        // What we get from HW is G/R. It is also programmable in the latest
        // HW.AWB_STATS_MODE=0-->G/R and AWB_STATS_MODE=1-->R/G. rg_coef is
        // actually R_gain applied to R Pixels. Since we get (G * G_gain) / (R *
        // R_gain) from HW, we multiply by the gain rg_coef to negate its
        // effect.
        uint16_t irg = BF_GET( data, 0, 16 );
        uint16_t ibg = BF_GET( data, 16, 16 );

        irg = ( irg * ( p_fsm->rg_coef ) ) >> 8;
        ibg = ( ibg * ( p_fsm->bg_coef ) ) >> 8;

        p_fsm->awb_zones[awb_record].rg = ( irg == 0 ) ? U16_MAX : ( U16_MAX / irg );
        p_fsm->awb_zones[awb_record].bg = ( ibg == 0 ) ? U16_MAX : ( U16_MAX / ibg );
        p_fsm->awb_zones[awb_record].sum = awb_get_data( isp_base, ( awb_record << 1 ) + 1 );
    }

    return 0;
}

void AWB_fsm_process_interrupt( const AWB_fsm_t *p_fsm, uint8_t irq_event )
{
    switch ( irq_event ) {
    case ACAMERA_IRQ_AWB_STATS:
        if ( awb_read_statistics( (AWB_fsm_t *)p_fsm ) == 0 ) {
            fsm_raise_event( p_fsm, event_id_isphw_stats_ready_awb );
        }
        break;
    }
}

////////////////////////////////////////////////////
// General router command handler

void awb_get_info( AWB_fsm_t *p_fsm, acamera_cmd_wb_info *p_info )
{
    system_memcpy( p_info->wb_log2, p_fsm->wb_log2, sizeof( p_info->wb_log2 ) );
    p_info->temperature_detected = p_fsm->temperature_detected;
    p_info->p_high = p_fsm->p_high;
    p_info->light_source_candidate = p_fsm->light_source_candidate;
}
